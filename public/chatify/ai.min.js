var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// assets/scripts/highlight.min.js
var require_highlight_min = __commonJS((exports, module) => {
  /*!
    Highlight.js v11.7.0 (git: 82688fad18)
    (c) 2006-2022 undefined and other contributors
    License: BSD-3-Clause
   */
  var hljs = function() {
    var e = { exports: {} };
    function n(e2) {
      return e2 instanceof Map ? e2.clear = e2.delete = e2.set = () => {
        throw Error("map is read-only");
      } : e2 instanceof Set && (e2.add = e2.clear = e2.delete = () => {
        throw Error("set is read-only");
      }), Object.freeze(e2), Object.getOwnPropertyNames(e2).forEach((t2) => {
        var a2 = e2[t2];
        typeof a2 != "object" || Object.isFrozen(a2) || n(a2);
      }), e2;
    }
    e.exports = n, e.exports.default = n;

    class t {
      constructor(e2) {
        e2.data === undefined && (e2.data = {}), this.data = e2.data, this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }
    function a(e2) {
      return e2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function i(e2, ...n2) {
      const t2 = Object.create(null);
      for (const n3 in e2)
        t2[n3] = e2[n3];
      return n2.forEach((e3) => {
        for (const n3 in e3)
          t2[n3] = e3[n3];
      }), t2;
    }
    const r = (e2) => !!e2.scope || e2.sublanguage && e2.language;

    class s {
      constructor(e2, n2) {
        this.buffer = "", this.classPrefix = n2.classPrefix, e2.walk(this);
      }
      addText(e2) {
        this.buffer += a(e2);
      }
      openNode(e2) {
        if (!r(e2))
          return;
        let n2 = "";
        n2 = e2.sublanguage ? "language-" + e2.language : ((e3, { prefix: n3 }) => {
          if (e3.includes(".")) {
            const t2 = e3.split(".");
            return [`${n3}${t2.shift()}`, ...t2.map((e4, n4) => `${e4}${"_".repeat(n4 + 1)}`)].join(" ");
          }
          return `${n3}${e3}`;
        })(e2.scope, { prefix: this.classPrefix }), this.span(n2);
      }
      closeNode(e2) {
        r(e2) && (this.buffer += "</span>");
      }
      value() {
        return this.buffer;
      }
      span(e2) {
        this.buffer += `<span class="${e2}">`;
      }
    }
    const o = (e2 = {}) => {
      const n2 = { children: [] };
      return Object.assign(n2, e2), n2;
    };

    class l {
      constructor() {
        this.rootNode = o(), this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      add(e2) {
        this.top.children.push(e2);
      }
      openNode(e2) {
        const n2 = o({ scope: e2 });
        this.add(n2), this.stack.push(n2);
      }
      closeNode() {
        if (this.stack.length > 1)
          return this.stack.pop();
      }
      closeAllNodes() {
        for (;this.closeNode(); )
          ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      walk(e2) {
        return this.constructor._walk(e2, this.rootNode);
      }
      static _walk(e2, n2) {
        return typeof n2 == "string" ? e2.addText(n2) : n2.children && (e2.openNode(n2), n2.children.forEach((n3) => this._walk(e2, n3)), e2.closeNode(n2)), e2;
      }
      static _collapse(e2) {
        typeof e2 != "string" && e2.children && (e2.children.every((e3) => typeof e3 == "string") ? e2.children = [e2.children.join("")] : e2.children.forEach((e3) => {
          l._collapse(e3);
        }));
      }
    }

    class c extends l {
      constructor(e2) {
        super(), this.options = e2;
      }
      addKeyword(e2, n2) {
        e2 !== "" && (this.openNode(n2), this.addText(e2), this.closeNode());
      }
      addText(e2) {
        e2 !== "" && this.add(e2);
      }
      addSublanguage(e2, n2) {
        const t2 = e2.root;
        t2.sublanguage = true, t2.language = n2, this.add(t2);
      }
      toHTML() {
        return new s(this, this.options).value();
      }
      finalize() {
        return true;
      }
    }
    function d(e2) {
      return e2 ? typeof e2 == "string" ? e2 : e2.source : null;
    }
    function g(e2) {
      return m("(?=", e2, ")");
    }
    function u(e2) {
      return m("(?:", e2, ")*");
    }
    function b(e2) {
      return m("(?:", e2, ")?");
    }
    function m(...e2) {
      return e2.map((e3) => d(e3)).join("");
    }
    function p(...e2) {
      const n2 = ((e3) => {
        const n3 = e3[e3.length - 1];
        return typeof n3 == "object" && n3.constructor === Object ? (e3.splice(e3.length - 1, 1), n3) : {};
      })(e2);
      return "(" + (n2.capture ? "" : "?:") + e2.map((e3) => d(e3)).join("|") + ")";
    }
    function _(e2) {
      return RegExp(e2.toString() + "|").exec("").length - 1;
    }
    const h = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function f(e2, { joinWith: n2 }) {
      let t2 = 0;
      return e2.map((e3) => {
        t2 += 1;
        const n3 = t2;
        let a2 = d(e3), i2 = "";
        for (;a2.length > 0; ) {
          const e4 = h.exec(a2);
          if (!e4) {
            i2 += a2;
            break;
          }
          i2 += a2.substring(0, e4.index), a2 = a2.substring(e4.index + e4[0].length), e4[0][0] === "\\" && e4[1] ? i2 += "\\" + (Number(e4[1]) + n3) : (i2 += e4[0], e4[0] === "(" && t2++);
        }
        return i2;
      }).map((e3) => `(${e3})`).join(n2);
    }
    const E = "[a-zA-Z]\\w*", y = "[a-zA-Z_]\\w*", w = "\\b\\d+(\\.\\d+)?", N = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", v = "\\b(0b[01]+)", O = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    }, k = {
      scope: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [O]
    }, x = {
      scope: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [O]
    }, M = (e2, n2, t2 = {}) => {
      const a2 = i({
        scope: "comment",
        begin: e2,
        end: n2,
        contains: []
      }, t2);
      a2.contains.push({
        scope: "doctag",
        begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
        excludeBegin: true,
        relevance: 0
      });
      const r2 = p("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/);
      return a2.contains.push({ begin: m(/[ ]+/, "(", r2, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), a2;
    }, S = M("//", "$"), A = M("/\\*", "\\*/"), C = M("#", "$");
    var T = Object.freeze({
      __proto__: null,
      MATCH_NOTHING_RE: /\b\B/,
      IDENT_RE: E,
      UNDERSCORE_IDENT_RE: y,
      NUMBER_RE: w,
      C_NUMBER_RE: N,
      BINARY_NUMBER_RE: v,
      RE_STARTERS_RE: "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
      SHEBANG: (e2 = {}) => {
        const n2 = /^#![ ]*\//;
        return e2.binary && (e2.begin = m(n2, /.*\b/, e2.binary, /\b.*/)), i({
          scope: "meta",
          begin: n2,
          end: /$/,
          relevance: 0,
          "on:begin": (e3, n3) => {
            e3.index !== 0 && n3.ignoreMatch();
          }
        }, e2);
      },
      BACKSLASH_ESCAPE: O,
      APOS_STRING_MODE: k,
      QUOTE_STRING_MODE: x,
      PHRASAL_WORDS_MODE: {
        begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
      },
      COMMENT: M,
      C_LINE_COMMENT_MODE: S,
      C_BLOCK_COMMENT_MODE: A,
      HASH_COMMENT_MODE: C,
      NUMBER_MODE: { scope: "number", begin: w, relevance: 0 },
      C_NUMBER_MODE: {
        scope: "number",
        begin: N,
        relevance: 0
      },
      BINARY_NUMBER_MODE: { scope: "number", begin: v, relevance: 0 },
      REGEXP_MODE: { begin: /(?=\/[^/\n]*\/)/, contains: [{
        scope: "regexp",
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [O, {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [O]
        }]
      }] },
      TITLE_MODE: { scope: "title", begin: E, relevance: 0 },
      UNDERSCORE_TITLE_MODE: { scope: "title", begin: y, relevance: 0 },
      METHOD_GUARD: {
        begin: "\\.\\s*[a-zA-Z_]\\w*",
        relevance: 0
      },
      END_SAME_AS_BEGIN: (e2) => Object.assign(e2, {
        "on:begin": (e3, n2) => {
          n2.data._beginMatch = e3[1];
        },
        "on:end": (e3, n2) => {
          n2.data._beginMatch !== e3[1] && n2.ignoreMatch();
        }
      })
    });
    function R(e2, n2) {
      e2.input[e2.index - 1] === "." && n2.ignoreMatch();
    }
    function D(e2, n2) {
      e2.className !== undefined && (e2.scope = e2.className, delete e2.className);
    }
    function I(e2, n2) {
      n2 && e2.beginKeywords && (e2.begin = "\\b(" + e2.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", e2.__beforeBegin = R, e2.keywords = e2.keywords || e2.beginKeywords, delete e2.beginKeywords, e2.relevance === undefined && (e2.relevance = 0));
    }
    function L(e2, n2) {
      Array.isArray(e2.illegal) && (e2.illegal = p(...e2.illegal));
    }
    function B(e2, n2) {
      if (e2.match) {
        if (e2.begin || e2.end)
          throw Error("begin & end are not supported with match");
        e2.begin = e2.match, delete e2.match;
      }
    }
    function $(e2, n2) {
      e2.relevance === undefined && (e2.relevance = 1);
    }
    const z = (e2, n2) => {
      if (!e2.beforeMatch)
        return;
      if (e2.starts)
        throw Error("beforeMatch cannot be used with starts");
      const t2 = Object.assign({}, e2);
      Object.keys(e2).forEach((n3) => {
        delete e2[n3];
      }), e2.keywords = t2.keywords, e2.begin = m(t2.beforeMatch, g(t2.begin)), e2.starts = {
        relevance: 0,
        contains: [Object.assign(t2, { endsParent: true })]
      }, e2.relevance = 0, delete t2.beforeMatch;
    }, F = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"];
    function U(e2, n2, t2 = "keyword") {
      const a2 = Object.create(null);
      return typeof e2 == "string" ? i2(t2, e2.split(" ")) : Array.isArray(e2) ? i2(t2, e2) : Object.keys(e2).forEach((t3) => {
        Object.assign(a2, U(e2[t3], n2, t3));
      }), a2;
      function i2(e3, t3) {
        n2 && (t3 = t3.map((e4) => e4.toLowerCase())), t3.forEach((n3) => {
          const t4 = n3.split("|");
          a2[t4[0]] = [e3, j(t4[0], t4[1])];
        });
      }
    }
    function j(e2, n2) {
      return n2 ? Number(n2) : ((e3) => F.includes(e3.toLowerCase()))(e2) ? 0 : 1;
    }
    const P = {}, K = (e2) => {
      console.error(e2);
    }, H = (e2, ...n2) => {
      console.log("WARN: " + e2, ...n2);
    }, q = (e2, n2) => {
      P[`${e2}/${n2}`] || (console.log(`Deprecated as of ${e2}. ${n2}`), P[`${e2}/${n2}`] = true);
    }, Z = Error();
    function G(e2, n2, { key: t2 }) {
      let a2 = 0;
      const i2 = e2[t2], r2 = {}, s2 = {};
      for (let e3 = 1;e3 <= n2.length; e3++)
        s2[e3 + a2] = i2[e3], r2[e3 + a2] = true, a2 += _(n2[e3 - 1]);
      e2[t2] = s2, e2[t2]._emit = r2, e2[t2]._multi = true;
    }
    function W(e2) {
      ((e3) => {
        e3.scope && typeof e3.scope == "object" && e3.scope !== null && (e3.beginScope = e3.scope, delete e3.scope);
      })(e2), typeof e2.beginScope == "string" && (e2.beginScope = {
        _wrap: e2.beginScope
      }), typeof e2.endScope == "string" && (e2.endScope = {
        _wrap: e2.endScope
      }), ((e3) => {
        if (Array.isArray(e3.begin)) {
          if (e3.skip || e3.excludeBegin || e3.returnBegin)
            throw K("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Z;
          if (typeof e3.beginScope != "object" || e3.beginScope === null)
            throw K("beginScope must be object"), Z;
          G(e3, e3.begin, { key: "beginScope" }), e3.begin = f(e3.begin, { joinWith: "" });
        }
      })(e2), ((e3) => {
        if (Array.isArray(e3.end)) {
          if (e3.skip || e3.excludeEnd || e3.returnEnd)
            throw K("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Z;
          if (typeof e3.endScope != "object" || e3.endScope === null)
            throw K("endScope must be object"), Z;
          G(e3, e3.end, { key: "endScope" }), e3.end = f(e3.end, { joinWith: "" });
        }
      })(e2);
    }
    function Q(e2) {
      function n2(n3, t3) {
        return RegExp(d(n3), "m" + (e2.case_insensitive ? "i" : "") + (e2.unicodeRegex ? "u" : "") + (t3 ? "g" : ""));
      }

      class t2 {
        constructor() {
          this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
        }
        addRule(e3, n3) {
          n3.position = this.position++, this.matchIndexes[this.matchAt] = n3, this.regexes.push([n3, e3]), this.matchAt += _(e3) + 1;
        }
        compile() {
          this.regexes.length === 0 && (this.exec = () => null);
          const e3 = this.regexes.map((e4) => e4[1]);
          this.matcherRe = n2(f(e3, {
            joinWith: "|"
          }), true), this.lastIndex = 0;
        }
        exec(e3) {
          this.matcherRe.lastIndex = this.lastIndex;
          const n3 = this.matcherRe.exec(e3);
          if (!n3)
            return null;
          const t3 = n3.findIndex((e4, n4) => n4 > 0 && e4 !== undefined), a3 = this.matchIndexes[t3];
          return n3.splice(0, t3), Object.assign(n3, a3);
        }
      }

      class a2 {
        constructor() {
          this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
        }
        getMatcher(e3) {
          if (this.multiRegexes[e3])
            return this.multiRegexes[e3];
          const n3 = new t2;
          return this.rules.slice(e3).forEach(([e4, t3]) => n3.addRule(e4, t3)), n3.compile(), this.multiRegexes[e3] = n3, n3;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        addRule(e3, n3) {
          this.rules.push([e3, n3]), n3.type === "begin" && this.count++;
        }
        exec(e3) {
          const n3 = this.getMatcher(this.regexIndex);
          n3.lastIndex = this.lastIndex;
          let t3 = n3.exec(e3);
          if (this.resumingScanAtSamePosition())
            if (t3 && t3.index === this.lastIndex)
              ;
            else {
              const n4 = this.getMatcher(0);
              n4.lastIndex = this.lastIndex + 1, t3 = n4.exec(e3);
            }
          return t3 && (this.regexIndex += t3.position + 1, this.regexIndex === this.count && this.considerAll()), t3;
        }
      }
      if (e2.compilerExtensions || (e2.compilerExtensions = []), e2.contains && e2.contains.includes("self"))
        throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      return e2.classNameAliases = i(e2.classNameAliases || {}), function t(r2, s2) {
        const o2 = r2;
        if (r2.isCompiled)
          return o2;
        [D, B, W, z].forEach((e3) => e3(r2, s2)), e2.compilerExtensions.forEach((e3) => e3(r2, s2)), r2.__beforeBegin = null, [I, L, $].forEach((e3) => e3(r2, s2)), r2.isCompiled = true;
        let l2 = null;
        return typeof r2.keywords == "object" && r2.keywords.$pattern && (r2.keywords = Object.assign({}, r2.keywords), l2 = r2.keywords.$pattern, delete r2.keywords.$pattern), l2 = l2 || /\w+/, r2.keywords && (r2.keywords = U(r2.keywords, e2.case_insensitive)), o2.keywordPatternRe = n2(l2, true), s2 && (r2.begin || (r2.begin = /\B|\b/), o2.beginRe = n2(o2.begin), r2.end || r2.endsWithParent || (r2.end = /\B|\b/), r2.end && (o2.endRe = n2(o2.end)), o2.terminatorEnd = d(o2.end) || "", r2.endsWithParent && s2.terminatorEnd && (o2.terminatorEnd += (r2.end ? "|" : "") + s2.terminatorEnd)), r2.illegal && (o2.illegalRe = n2(r2.illegal)), r2.contains || (r2.contains = []), r2.contains = [].concat(...r2.contains.map((e3) => ((e4) => (e4.variants && !e4.cachedVariants && (e4.cachedVariants = e4.variants.map((n3) => i(e4, {
          variants: null
        }, n3))), e4.cachedVariants ? e4.cachedVariants : X(e4) ? i(e4, {
          starts: e4.starts ? i(e4.starts) : null
        }) : Object.isFrozen(e4) ? i(e4) : e4))(e3 === "self" ? r2 : e3))), r2.contains.forEach((e3) => {
          t(e3, o2);
        }), r2.starts && t(r2.starts, s2), o2.matcher = ((e3) => {
          const n3 = new a2;
          return e3.contains.forEach((e4) => n3.addRule(e4.begin, {
            rule: e4,
            type: "begin"
          })), e3.terminatorEnd && n3.addRule(e3.terminatorEnd, {
            type: "end"
          }), e3.illegal && n3.addRule(e3.illegal, { type: "illegal" }), n3;
        })(o2), o2;
      }(e2);
    }
    function X(e2) {
      return !!e2 && (e2.endsWithParent || X(e2.starts));
    }

    class V extends Error {
      constructor(e2, n2) {
        super(e2), this.name = "HTMLInjectionError", this.html = n2;
      }
    }
    const J = a, Y = i, ee = Symbol("nomatch");
    var ne = ((n2) => {
      const a2 = Object.create(null), i2 = Object.create(null), r2 = [];
      let s2 = true;
      const o2 = "Could not find the language '{}', did you forget to load/include a language module?", l2 = {
        disableAutodetect: true,
        name: "Plain text",
        contains: []
      };
      let d2 = {
        ignoreUnescapedHTML: false,
        throwUnescapedHTML: false,
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        cssSelector: "pre code",
        languages: null,
        __emitter: c
      };
      function _2(e2) {
        return d2.noHighlightRe.test(e2);
      }
      function h2(e2, n3, t2) {
        let a3 = "", i3 = "";
        typeof n3 == "object" ? (a3 = e2, t2 = n3.ignoreIllegals, i3 = n3.language) : (q("10.7.0", "highlight(lang, code, ...args) has been deprecated."), q("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"), i3 = e2, a3 = n3), t2 === undefined && (t2 = true);
        const r3 = { code: a3, language: i3 };
        x2("before:highlight", r3);
        const s3 = r3.result ? r3.result : f2(r3.language, r3.code, t2);
        return s3.code = r3.code, x2("after:highlight", s3), s3;
      }
      function f2(e2, n3, i3, r3) {
        const l3 = Object.create(null);
        function c2() {
          if (!k3.keywords)
            return void M2.addText(S2);
          let e3 = 0;
          k3.keywordPatternRe.lastIndex = 0;
          let n4 = k3.keywordPatternRe.exec(S2), t2 = "";
          for (;n4; ) {
            t2 += S2.substring(e3, n4.index);
            const i4 = w3.case_insensitive ? n4[0].toLowerCase() : n4[0], r4 = (a3 = i4, k3.keywords[a3]);
            if (r4) {
              const [e4, a4] = r4;
              if (M2.addText(t2), t2 = "", l3[i4] = (l3[i4] || 0) + 1, l3[i4] <= 7 && (A2 += a4), e4.startsWith("_"))
                t2 += n4[0];
              else {
                const t3 = w3.classNameAliases[e4] || e4;
                M2.addKeyword(n4[0], t3);
              }
            } else
              t2 += n4[0];
            e3 = k3.keywordPatternRe.lastIndex, n4 = k3.keywordPatternRe.exec(S2);
          }
          var a3;
          t2 += S2.substring(e3), M2.addText(t2);
        }
        function g2() {
          k3.subLanguage != null ? (() => {
            if (S2 === "")
              return;
            let e3 = null;
            if (typeof k3.subLanguage == "string") {
              if (!a2[k3.subLanguage])
                return void M2.addText(S2);
              e3 = f2(k3.subLanguage, S2, true, x3[k3.subLanguage]), x3[k3.subLanguage] = e3._top;
            } else
              e3 = E2(S2, k3.subLanguage.length ? k3.subLanguage : null);
            k3.relevance > 0 && (A2 += e3.relevance), M2.addSublanguage(e3._emitter, e3.language);
          })() : c2(), S2 = "";
        }
        function u2(e3, n4) {
          let t2 = 1;
          const a3 = n4.length - 1;
          for (;t2 <= a3; ) {
            if (!e3._emit[t2]) {
              t2++;
              continue;
            }
            const a4 = w3.classNameAliases[e3[t2]] || e3[t2], i4 = n4[t2];
            a4 ? M2.addKeyword(i4, a4) : (S2 = i4, c2(), S2 = ""), t2++;
          }
        }
        function b2(e3, n4) {
          return e3.scope && typeof e3.scope == "string" && M2.openNode(w3.classNameAliases[e3.scope] || e3.scope), e3.beginScope && (e3.beginScope._wrap ? (M2.addKeyword(S2, w3.classNameAliases[e3.beginScope._wrap] || e3.beginScope._wrap), S2 = "") : e3.beginScope._multi && (u2(e3.beginScope, n4), S2 = "")), k3 = Object.create(e3, { parent: {
            value: k3
          } }), k3;
        }
        function m2(e3, n4, a3) {
          let i4 = ((e4, n5) => {
            const t2 = e4 && e4.exec(n5);
            return t2 && t2.index === 0;
          })(e3.endRe, a3);
          if (i4) {
            if (e3["on:end"]) {
              const a4 = new t(e3);
              e3["on:end"](n4, a4), a4.isMatchIgnored && (i4 = false);
            }
            if (i4) {
              for (;e3.endsParent && e3.parent; )
                e3 = e3.parent;
              return e3;
            }
          }
          if (e3.endsWithParent)
            return m2(e3.parent, n4, a3);
        }
        function p2(e3) {
          return k3.matcher.regexIndex === 0 ? (S2 += e3[0], 1) : (R2 = true, 0);
        }
        function _3(e3) {
          const t2 = e3[0], a3 = n3.substring(e3.index), i4 = m2(k3, e3, a3);
          if (!i4)
            return ee;
          const r4 = k3;
          k3.endScope && k3.endScope._wrap ? (g2(), M2.addKeyword(t2, k3.endScope._wrap)) : k3.endScope && k3.endScope._multi ? (g2(), u2(k3.endScope, e3)) : r4.skip ? S2 += t2 : (r4.returnEnd || r4.excludeEnd || (S2 += t2), g2(), r4.excludeEnd && (S2 = t2));
          do {
            k3.scope && M2.closeNode(), k3.skip || k3.subLanguage || (A2 += k3.relevance), k3 = k3.parent;
          } while (k3 !== i4.parent);
          return i4.starts && b2(i4.starts, e3), r4.returnEnd ? 0 : t2.length;
        }
        let h3 = {};
        function y3(a3, r4) {
          const o3 = r4 && r4[0];
          if (S2 += a3, o3 == null)
            return g2(), 0;
          if (h3.type === "begin" && r4.type === "end" && h3.index === r4.index && o3 === "") {
            if (S2 += n3.slice(r4.index, r4.index + 1), !s2) {
              const n4 = Error(`0 width match regex (${e2})`);
              throw n4.languageName = e2, n4.badRule = h3.rule, n4;
            }
            return 1;
          }
          if (h3 = r4, r4.type === "begin")
            return ((e3) => {
              const n4 = e3[0], a4 = e3.rule, i4 = new t(a4), r5 = [a4.__beforeBegin, a4["on:begin"]];
              for (const t2 of r5)
                if (t2 && (t2(e3, i4), i4.isMatchIgnored))
                  return p2(n4);
              return a4.skip ? S2 += n4 : (a4.excludeBegin && (S2 += n4), g2(), a4.returnBegin || a4.excludeBegin || (S2 = n4)), b2(a4, e3), a4.returnBegin ? 0 : n4.length;
            })(r4);
          if (r4.type === "illegal" && !i3) {
            const e3 = Error('Illegal lexeme "' + o3 + '" for mode "' + (k3.scope || "<unnamed>") + '"');
            throw e3.mode = k3, e3;
          }
          if (r4.type === "end") {
            const e3 = _3(r4);
            if (e3 !== ee)
              return e3;
          }
          if (r4.type === "illegal" && o3 === "")
            return 1;
          if (T2 > 1e5 && T2 > 3 * r4.index)
            throw Error("potential infinite loop, way more iterations than matches");
          return S2 += o3, o3.length;
        }
        const w3 = v2(e2);
        if (!w3)
          throw K(o2.replace("{}", e2)), Error('Unknown language: "' + e2 + '"');
        const N3 = Q(w3);
        let O3 = "", k3 = r3 || N3;
        const x3 = {}, M2 = new d2.__emitter(d2);
        (() => {
          const e3 = [];
          for (let n4 = k3;n4 !== w3; n4 = n4.parent)
            n4.scope && e3.unshift(n4.scope);
          e3.forEach((e4) => M2.openNode(e4));
        })();
        let S2 = "", A2 = 0, C2 = 0, T2 = 0, R2 = false;
        try {
          for (k3.matcher.considerAll();; ) {
            T2++, R2 ? R2 = false : k3.matcher.considerAll(), k3.matcher.lastIndex = C2;
            const e3 = k3.matcher.exec(n3);
            if (!e3)
              break;
            const t2 = y3(n3.substring(C2, e3.index), e3);
            C2 = e3.index + t2;
          }
          return y3(n3.substring(C2)), M2.closeAllNodes(), M2.finalize(), O3 = M2.toHTML(), {
            language: e2,
            value: O3,
            relevance: A2,
            illegal: false,
            _emitter: M2,
            _top: k3
          };
        } catch (t2) {
          if (t2.message && t2.message.includes("Illegal"))
            return {
              language: e2,
              value: J(n3),
              illegal: true,
              relevance: 0,
              _illegalBy: {
                message: t2.message,
                index: C2,
                context: n3.slice(C2 - 100, C2 + 100),
                mode: t2.mode,
                resultSoFar: O3
              },
              _emitter: M2
            };
          if (s2)
            return {
              language: e2,
              value: J(n3),
              illegal: false,
              relevance: 0,
              errorRaised: t2,
              _emitter: M2,
              _top: k3
            };
          throw t2;
        }
      }
      function E2(e2, n3) {
        n3 = n3 || d2.languages || Object.keys(a2);
        const t2 = ((e3) => {
          const n4 = { value: J(e3), illegal: false, relevance: 0, _top: l2, _emitter: new d2.__emitter(d2) };
          return n4._emitter.addText(e3), n4;
        })(e2), i3 = n3.filter(v2).filter(k2).map((n4) => f2(n4, e2, false));
        i3.unshift(t2);
        const r3 = i3.sort((e3, n4) => {
          if (e3.relevance !== n4.relevance)
            return n4.relevance - e3.relevance;
          if (e3.language && n4.language) {
            if (v2(e3.language).supersetOf === n4.language)
              return 1;
            if (v2(n4.language).supersetOf === e3.language)
              return -1;
          }
          return 0;
        }), [s3, o3] = r3, c2 = s3;
        return c2.secondBest = o3, c2;
      }
      function y2(e2) {
        let n3 = null;
        const t2 = ((e3) => {
          let n4 = e3.className + " ";
          n4 += e3.parentNode ? e3.parentNode.className : "";
          const t3 = d2.languageDetectRe.exec(n4);
          if (t3) {
            const n5 = v2(t3[1]);
            return n5 || (H(o2.replace("{}", t3[1])), H("Falling back to no-highlight mode for this block.", e3)), n5 ? t3[1] : "no-highlight";
          }
          return n4.split(/\s+/).find((e4) => _2(e4) || v2(e4));
        })(e2);
        if (_2(t2))
          return;
        if (x2("before:highlightElement", {
          el: e2,
          language: t2
        }), e2.children.length > 0 && (d2.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(e2)), d2.throwUnescapedHTML))
          throw new V("One of your code blocks includes unescaped HTML.", e2.innerHTML);
        n3 = e2;
        const a3 = n3.textContent, r3 = t2 ? h2(a3, { language: t2, ignoreIllegals: true }) : E2(a3);
        e2.innerHTML = r3.value, ((e3, n4, t3) => {
          const a4 = n4 && i2[n4] || t3;
          e3.classList.add("hljs"), e3.classList.add("language-" + a4);
        })(e2, t2, r3.language), e2.result = {
          language: r3.language,
          re: r3.relevance,
          relevance: r3.relevance
        }, r3.secondBest && (e2.secondBest = {
          language: r3.secondBest.language,
          relevance: r3.secondBest.relevance
        }), x2("after:highlightElement", { el: e2, result: r3, text: a3 });
      }
      let w2 = false;
      function N2() {
        document.readyState !== "loading" ? document.querySelectorAll(d2.cssSelector).forEach(y2) : w2 = true;
      }
      function v2(e2) {
        return e2 = (e2 || "").toLowerCase(), a2[e2] || a2[i2[e2]];
      }
      function O2(e2, { languageName: n3 }) {
        typeof e2 == "string" && (e2 = [e2]), e2.forEach((e3) => {
          i2[e3.toLowerCase()] = n3;
        });
      }
      function k2(e2) {
        const n3 = v2(e2);
        return n3 && !n3.disableAutodetect;
      }
      function x2(e2, n3) {
        const t2 = e2;
        r2.forEach((e3) => {
          e3[t2] && e3[t2](n3);
        });
      }
      typeof window != "undefined" && window.addEventListener && window.addEventListener("DOMContentLoaded", () => {
        w2 && N2();
      }, false), Object.assign(n2, {
        highlight: h2,
        highlightAuto: E2,
        highlightAll: N2,
        highlightElement: y2,
        highlightBlock: (e2) => (q("10.7.0", "highlightBlock will be removed entirely in v12.0"), q("10.7.0", "Please use highlightElement now."), y2(e2)),
        configure: (e2) => {
          d2 = Y(d2, e2);
        },
        initHighlighting: () => {
          N2(), q("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
        },
        initHighlightingOnLoad: () => {
          N2(), q("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
        },
        registerLanguage: (e2, t2) => {
          let i3 = null;
          try {
            i3 = t2(n2);
          } catch (n3) {
            if (K("Language definition for '{}' could not be registered.".replace("{}", e2)), !s2)
              throw n3;
            K(n3), i3 = l2;
          }
          i3.name || (i3.name = e2), a2[e2] = i3, i3.rawDefinition = t2.bind(null, n2), i3.aliases && O2(i3.aliases, {
            languageName: e2
          });
        },
        unregisterLanguage: (e2) => {
          delete a2[e2];
          for (const n3 of Object.keys(i2))
            i2[n3] === e2 && delete i2[n3];
        },
        listLanguages: () => Object.keys(a2),
        getLanguage: v2,
        registerAliases: O2,
        autoDetection: k2,
        inherit: Y,
        addPlugin: (e2) => {
          ((e3) => {
            e3["before:highlightBlock"] && !e3["before:highlightElement"] && (e3["before:highlightElement"] = (n3) => {
              e3["before:highlightBlock"](Object.assign({ block: n3.el }, n3));
            }), e3["after:highlightBlock"] && !e3["after:highlightElement"] && (e3["after:highlightElement"] = (n3) => {
              e3["after:highlightBlock"](Object.assign({ block: n3.el }, n3));
            });
          })(e2), r2.push(e2);
        }
      }), n2.debugMode = () => {
        s2 = false;
      }, n2.safeMode = () => {
        s2 = true;
      }, n2.versionString = "11.7.0", n2.regex = {
        concat: m,
        lookahead: g,
        either: p,
        optional: b,
        anyNumberOfTimes: u
      };
      for (const n3 in T)
        typeof T[n3] == "object" && e.exports(T[n3]);
      return Object.assign(n2, T), n2;
    })({});
    const te = (e2) => ({
      IMPORTANT: {
        scope: "meta",
        begin: "!important"
      },
      BLOCK_COMMENT: e2.C_BLOCK_COMMENT_MODE,
      HEXCOLOR: {
        scope: "number",
        begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
      },
      FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ },
      ATTRIBUTE_SELECTOR_MODE: {
        scope: "selector-attr",
        begin: /\[/,
        end: /\]/,
        illegal: "$",
        contains: [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE]
      },
      CSS_NUMBER_MODE: {
        scope: "number",
        begin: e2.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
        relevance: 0
      },
      CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z][A-Za-z0-9_-]*/ }
    }), ae = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "p", "q", "quote", "samp", "section", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"], ie = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"], re = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"], se = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"], oe = ["align-content", "align-items", "align-self", "all", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "block-size", "border", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "content", "content-visibility", "counter-increment", "counter-reset", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "empty-cells", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "gap", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "inline-size", "isolation", "justify-content", "left", "letter-spacing", "line-break", "line-height", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page-break-after", "page-break-before", "page-break-inside", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pointer-events", "position", "quotes", "resize", "rest", "rest-after", "rest-before", "right", "row-gap", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "scrollbar-color", "scrollbar-gutter", "scrollbar-width", "shape-image-threshold", "shape-margin", "shape-outside", "speak", "speak-as", "src", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-transform", "text-underline-position", "top", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index"].reverse(), le = re.concat(se);
    var ce = "\\.([0-9](_*[0-9])*)", de = "[0-9a-fA-F](_*[0-9a-fA-F])*", ge = {
      className: "number",
      variants: [{
        begin: `(\\b([0-9](_*[0-9])*)((${ce})|\\.)?|(${ce}))[eE][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`
      }, { begin: `\\b([0-9](_*[0-9])*)((${ce})[fFdD]?\\b|\\.([fFdD]\\b)?)` }, {
        begin: `(${ce})[fFdD]?\\b`
      }, { begin: "\\b([0-9](_*[0-9])*)[fFdD]\\b" }, {
        begin: `\\b0[xX]((${de})\\.?|(${de})?\\.(${de}))[pP][+-]?([0-9](_*[0-9])*)[fFdD]?\\b`
      }, { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" }, { begin: `\\b0[xX](${de})[lL]?\\b` }, {
        begin: "\\b0(_*[0-7])*[lL]?\\b"
      }, { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }],
      relevance: 0
    };
    function ue(e2, n2, t2) {
      return t2 === -1 ? "" : e2.replace(n2, (a2) => ue(e2, n2, t2 - 1));
    }
    const be = "[A-Za-z$_][0-9A-Za-z$_]*", me = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends"], pe = ["true", "false", "null", "undefined", "NaN", "Infinity"], _e = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"], he = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"], fe = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"], Ee = ["arguments", "this", "super", "console", "window", "document", "localStorage", "module", "global"], ye = [].concat(fe, _e, he);
    function we(e2) {
      const n2 = e2.regex, t2 = be, a2 = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        isTrulyOpeningTag: (e3, n3) => {
          const t3 = e3[0].length + e3.index, a3 = e3.input[t3];
          if (a3 === "<" || a3 === ",")
            return void n3.ignoreMatch();
          let i3;
          a3 === ">" && (((e4, { after: n4 }) => {
            const t4 = "</" + e4[0].slice(1);
            return e4.input.indexOf(t4, n4) !== -1;
          })(e3, { after: t3 }) || n3.ignoreMatch());
          const r3 = e3.input.substring(t3);
          ((i3 = r3.match(/^\s*=/)) || (i3 = r3.match(/^\s+extends\s+/)) && i3.index === 0) && n3.ignoreMatch();
        }
      }, i2 = {
        $pattern: be,
        keyword: me,
        literal: pe,
        built_in: ye,
        "variable.language": Ee
      }, r2 = "\\.([0-9](_?[0-9])*)", s2 = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", o2 = {
        className: "number",
        variants: [{
          begin: `(\\b(${s2})((${r2})|\\.)?|(${r2}))[eE][+-]?([0-9](_?[0-9])*)\\b`
        }, {
          begin: `\\b(${s2})\\b((${r2})\\b|\\.)?|(${r2})\\b`
        }, {
          begin: "\\b(0|[1-9](_?[0-9])*)n\\b"
        }, {
          begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"
        }, {
          begin: "\\b0[bB][0-1](_?[0-1])*n?\\b"
        }, { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" }, {
          begin: "\\b0[0-7]+n?\\b"
        }],
        relevance: 0
      }, l2 = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: i2,
        contains: []
      }, c2 = { begin: "html`", end: "", starts: {
        end: "`",
        returnEnd: false,
        contains: [e2.BACKSLASH_ESCAPE, l2],
        subLanguage: "xml"
      } }, d2 = {
        begin: "css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [e2.BACKSLASH_ESCAPE, l2],
          subLanguage: "css"
        }
      }, g2 = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [e2.BACKSLASH_ESCAPE, l2]
      }, u2 = {
        className: "comment",
        variants: [e2.COMMENT(/\/\*\*(?!\/)/, "\\*/", {
          relevance: 0,
          contains: [{
            begin: "(?=@[A-Za-z]+)",
            relevance: 0,
            contains: [{
              className: "doctag",
              begin: "@[A-Za-z]+"
            }, {
              className: "type",
              begin: "\\{",
              end: "\\}",
              excludeEnd: true,
              excludeBegin: true,
              relevance: 0
            }, {
              className: "variable",
              begin: t2 + "(?=\\s*(-)|$)",
              endsParent: true,
              relevance: 0
            }, { begin: /(?=[^\n])\s/, relevance: 0 }]
          }]
        }), e2.C_BLOCK_COMMENT_MODE, e2.C_LINE_COMMENT_MODE]
      }, b2 = [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, c2, d2, g2, { match: /\$\d+/ }, o2];
      l2.contains = b2.concat({
        begin: /\{/,
        end: /\}/,
        keywords: i2,
        contains: ["self"].concat(b2)
      });
      const m2 = [].concat(u2, l2.contains), p2 = m2.concat([{
        begin: /\(/,
        end: /\)/,
        keywords: i2,
        contains: ["self"].concat(m2)
      }]), _2 = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: i2,
        contains: p2
      }, h2 = { variants: [{
        match: [/class/, /\s+/, t2, /\s+/, /extends/, /\s+/, n2.concat(t2, "(", n2.concat(/\./, t2), ")*")],
        scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" }
      }, {
        match: [/class/, /\s+/, t2],
        scope: { 1: "keyword", 3: "title.class" }
      }] }, f2 = {
        relevance: 0,
        match: n2.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),
        className: "title.class",
        keywords: { _: [..._e, ...he] }
      }, E2 = {
        variants: [{
          match: [/function/, /\s+/, t2, /(?=\s*\()/]
        }, { match: [/function/, /\s*(?=\()/] }],
        className: { 1: "keyword", 3: "title.function" },
        label: "func.def",
        contains: [_2],
        illegal: /%/
      }, y2 = {
        match: n2.concat(/\b/, (w2 = [...fe, "super", "import"], n2.concat("(?!", w2.join("|"), ")")), t2, n2.lookahead(/\(/)),
        className: "title.function",
        relevance: 0
      };
      var w2;
      const N2 = {
        begin: n2.concat(/\./, n2.lookahead(n2.concat(t2, /(?![0-9A-Za-z$_(])/))),
        end: t2,
        excludeBegin: true,
        keywords: "prototype",
        className: "property",
        relevance: 0
      }, v2 = {
        match: [/get|set/, /\s+/, t2, /(?=\()/],
        className: { 1: "keyword", 3: "title.function" },
        contains: [{ begin: /\(\)/ }, _2]
      }, O2 = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + e2.UNDERSCORE_IDENT_RE + ")\\s*=>", k2 = {
        match: [/const|var|let/, /\s+/, t2, /\s*/, /=\s*/, /(async\s*)?/, n2.lookahead(O2)],
        keywords: "async",
        className: { 1: "keyword", 3: "title.function" },
        contains: [_2]
      };
      return {
        name: "Javascript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: i2,
        exports: {
          PARAMS_CONTAINS: p2,
          CLASS_REFERENCE: f2
        },
        illegal: /#(?![$_A-z])/,
        contains: [e2.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }), {
          label: "use_strict",
          className: "meta",
          relevance: 10,
          begin: /^\s*['"]use (strict|asm)['"]/
        }, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, c2, d2, g2, u2, { match: /\$\d+/ }, o2, f2, {
          className: "attr",
          begin: t2 + n2.lookahead(":"),
          relevance: 0
        }, k2, {
          begin: "(" + e2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          relevance: 0,
          contains: [u2, e2.REGEXP_MODE, {
            className: "function",
            begin: O2,
            returnBegin: true,
            end: "\\s*=>",
            contains: [{
              className: "params",
              variants: [{ begin: e2.UNDERSCORE_IDENT_RE, relevance: 0 }, {
                className: null,
                begin: /\(\s*\)/,
                skip: true
              }, {
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: i2,
                contains: p2
              }]
            }]
          }, { begin: /,/, relevance: 0 }, {
            match: /\s+/,
            relevance: 0
          }, { variants: [{ begin: "<>", end: "</>" }, {
            match: /<[A-Za-z0-9\\._:-]+\s*\/>/
          }, {
            begin: a2.begin,
            "on:begin": a2.isTrulyOpeningTag,
            end: a2.end
          }], subLanguage: "xml", contains: [{
            begin: a2.begin,
            end: a2.end,
            skip: true,
            contains: ["self"]
          }] }]
        }, E2, {
          beginKeywords: "while if switch catch for"
        }, {
          begin: "\\b(?!function)" + e2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          returnBegin: true,
          label: "func.def",
          contains: [_2, e2.inherit(e2.TITLE_MODE, {
            begin: t2,
            className: "title.function"
          })]
        }, { match: /\.\.\./, relevance: 0 }, N2, {
          match: "\\$" + t2,
          relevance: 0
        }, {
          match: [/\bconstructor(?=\s*\()/],
          className: { 1: "title.function" },
          contains: [_2]
        }, y2, {
          relevance: 0,
          match: /\b[A-Z][A-Z_0-9]+\b/,
          className: "variable.constant"
        }, h2, v2, { match: /\$[(.]/ }]
      };
    }
    const Ne = (e2) => m(/\b/, e2, /\w$/.test(e2) ? /\b/ : /\B/), ve = ["Protocol", "Type"].map(Ne), Oe = ["init", "self"].map(Ne), ke = ["Any", "Self"], xe = ["actor", "any", "associatedtype", "async", "await", /as\?/, /as!/, "as", "break", "case", "catch", "class", "continue", "convenience", "default", "defer", "deinit", "didSet", "distributed", "do", "dynamic", "else", "enum", "extension", "fallthrough", /fileprivate\(set\)/, "fileprivate", "final", "for", "func", "get", "guard", "if", "import", "indirect", "infix", /init\?/, /init!/, "inout", /internal\(set\)/, "internal", "in", "is", "isolated", "nonisolated", "lazy", "let", "mutating", "nonmutating", /open\(set\)/, "open", "operator", "optional", "override", "postfix", "precedencegroup", "prefix", /private\(set\)/, "private", "protocol", /public\(set\)/, "public", "repeat", "required", "rethrows", "return", "set", "some", "static", "struct", "subscript", "super", "switch", "throws", "throw", /try\?/, /try!/, "try", "typealias", /unowned\(safe\)/, /unowned\(unsafe\)/, "unowned", "var", "weak", "where", "while", "willSet"], Me = ["false", "nil", "true"], Se = ["assignment", "associativity", "higherThan", "left", "lowerThan", "none", "right"], Ae = ["#colorLiteral", "#column", "#dsohandle", "#else", "#elseif", "#endif", "#error", "#file", "#fileID", "#fileLiteral", "#filePath", "#function", "#if", "#imageLiteral", "#keyPath", "#line", "#selector", "#sourceLocation", "#warn_unqualified_access", "#warning"], Ce = ["abs", "all", "any", "assert", "assertionFailure", "debugPrint", "dump", "fatalError", "getVaList", "isKnownUniquelyReferenced", "max", "min", "numericCast", "pointwiseMax", "pointwiseMin", "precondition", "preconditionFailure", "print", "readLine", "repeatElement", "sequence", "stride", "swap", "swift_unboxFromSwiftValueWithType", "transcode", "type", "unsafeBitCast", "unsafeDowncast", "withExtendedLifetime", "withUnsafeMutablePointer", "withUnsafePointer", "withVaList", "withoutActuallyEscaping", "zip"], Te = p(/[/=\-+!*%<>&|^~?]/, /[\u00A1-\u00A7]/, /[\u00A9\u00AB]/, /[\u00AC\u00AE]/, /[\u00B0\u00B1]/, /[\u00B6\u00BB\u00BF\u00D7\u00F7]/, /[\u2016-\u2017]/, /[\u2020-\u2027]/, /[\u2030-\u203E]/, /[\u2041-\u2053]/, /[\u2055-\u205E]/, /[\u2190-\u23FF]/, /[\u2500-\u2775]/, /[\u2794-\u2BFF]/, /[\u2E00-\u2E7F]/, /[\u3001-\u3003]/, /[\u3008-\u3020]/, /[\u3030]/), Re = p(Te, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/), De = m(Te, Re, "*"), Ie = p(/[a-zA-Z_]/, /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/, /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/, /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/, /[\u1E00-\u1FFF]/, /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/, /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/, /[\u2C00-\u2DFF\u2E80-\u2FFF]/, /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/, /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/, /[\uFE47-\uFEFE\uFF00-\uFFFD]/), Le = p(Ie, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/), Be = m(Ie, Le, "*"), $e = m(/[A-Z]/, Le, "*"), ze = ["autoclosure", m(/convention\(/, p("swift", "block", "c"), /\)/), "discardableResult", "dynamicCallable", "dynamicMemberLookup", "escaping", "frozen", "GKInspectable", "IBAction", "IBDesignable", "IBInspectable", "IBOutlet", "IBSegueAction", "inlinable", "main", "nonobjc", "NSApplicationMain", "NSCopying", "NSManaged", m(/objc\(/, Be, /\)/), "objc", "objcMembers", "propertyWrapper", "requires_stored_property_inits", "resultBuilder", "testable", "UIApplicationMain", "unknown", "usableFromInline"], Fe = ["iOS", "iOSApplicationExtension", "macOS", "macOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "watchOS", "watchOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "swift"];
    var Ue = Object.freeze({
      __proto__: null,
      grmr_bash: (e2) => {
        const n2 = e2.regex, t2 = {}, a2 = {
          begin: /\$\{/,
          end: /\}/,
          contains: ["self", { begin: /:-/, contains: [t2] }]
        };
        Object.assign(t2, { className: "variable", variants: [{
          begin: n2.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])")
        }, a2] });
        const i2 = {
          className: "subst",
          begin: /\$\(/,
          end: /\)/,
          contains: [e2.BACKSLASH_ESCAPE]
        }, r2 = {
          begin: /<<-?\s*(?=\w+)/,
          starts: { contains: [e2.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: "string"
          })] }
        }, s2 = {
          className: "string",
          begin: /"/,
          end: /"/,
          contains: [e2.BACKSLASH_ESCAPE, t2, i2]
        };
        i2.contains.push(s2);
        const o2 = {
          begin: /\$?\(\(/,
          end: /\)\)/,
          contains: [{ begin: /\d+#[0-9a-f]+/, className: "number" }, e2.NUMBER_MODE, t2]
        }, l2 = e2.SHEBANG({
          binary: "(fish|bash|zsh|sh|csh|ksh|tcsh|dash|scsh)",
          relevance: 10
        }), c2 = {
          className: "function",
          begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
          returnBegin: true,
          contains: [e2.inherit(e2.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
          relevance: 0
        };
        return {
          name: "Bash",
          aliases: ["sh"],
          keywords: {
            $pattern: /\b[a-z][a-z0-9._-]+\b/,
            keyword: ["if", "then", "else", "elif", "fi", "for", "while", "in", "do", "done", "case", "esac", "function"],
            literal: ["true", "false"],
            built_in: ["break", "cd", "continue", "eval", "exec", "exit", "export", "getopts", "hash", "pwd", "readonly", "return", "shift", "test", "times", "trap", "umask", "unset", "alias", "bind", "builtin", "caller", "command", "declare", "echo", "enable", "help", "let", "local", "logout", "mapfile", "printf", "read", "readarray", "source", "type", "typeset", "ulimit", "unalias", "set", "shopt", "autoload", "bg", "bindkey", "bye", "cap", "chdir", "clone", "comparguments", "compcall", "compctl", "compdescribe", "compfiles", "compgroups", "compquote", "comptags", "comptry", "compvalues", "dirs", "disable", "disown", "echotc", "echoti", "emulate", "fc", "fg", "float", "functions", "getcap", "getln", "history", "integer", "jobs", "kill", "limit", "log", "noglob", "popd", "print", "pushd", "pushln", "rehash", "sched", "setcap", "setopt", "stat", "suspend", "ttyctl", "unfunction", "unhash", "unlimit", "unsetopt", "vared", "wait", "whence", "where", "which", "zcompile", "zformat", "zftp", "zle", "zmodload", "zparseopts", "zprof", "zpty", "zregexparse", "zsocket", "zstyle", "ztcp", "chcon", "chgrp", "chown", "chmod", "cp", "dd", "df", "dir", "dircolors", "ln", "ls", "mkdir", "mkfifo", "mknod", "mktemp", "mv", "realpath", "rm", "rmdir", "shred", "sync", "touch", "truncate", "vdir", "b2sum", "base32", "base64", "cat", "cksum", "comm", "csplit", "cut", "expand", "fmt", "fold", "head", "join", "md5sum", "nl", "numfmt", "od", "paste", "ptx", "pr", "sha1sum", "sha224sum", "sha256sum", "sha384sum", "sha512sum", "shuf", "sort", "split", "sum", "tac", "tail", "tr", "tsort", "unexpand", "uniq", "wc", "arch", "basename", "chroot", "date", "dirname", "du", "echo", "env", "expr", "factor", "groups", "hostid", "id", "link", "logname", "nice", "nohup", "nproc", "pathchk", "pinky", "printenv", "printf", "pwd", "readlink", "runcon", "seq", "sleep", "stat", "stdbuf", "stty", "tee", "test", "timeout", "tty", "uname", "unlink", "uptime", "users", "who", "whoami", "yes"]
          },
          contains: [l2, e2.SHEBANG(), c2, o2, e2.HASH_COMMENT_MODE, r2, { match: /(\/[a-z._-]+)+/ }, s2, {
            className: "",
            begin: /\\"/
          }, { className: "string", begin: /'/, end: /'/ }, t2]
        };
      },
      grmr_c: (e2) => {
        const n2 = e2.regex, t2 = e2.COMMENT("//", "$", {
          contains: [{ begin: /\\\n/ }]
        }), a2 = "[a-zA-Z_]\\w*::", i2 = "(decltype\\(auto\\)|" + n2.optional(a2) + "[a-zA-Z_]\\w*" + n2.optional("<[^<>]+>") + ")", r2 = {
          className: "type",
          variants: [{ begin: "\\b[a-z\\d_]*_t\\b" }, {
            match: /\batomic_[a-z]{3,6}\b/
          }]
        }, s2 = { className: "string", variants: [{
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e2.BACKSLASH_ESCAPE]
        }, {
          begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
          end: "'",
          illegal: "."
        }, e2.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/
        })] }, o2 = {
          className: "number",
          variants: [{ begin: "\\b(0b[01']+)" }, {
            begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
          }, {
            begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
          }],
          relevance: 0
        }, l2 = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: {
          keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
        }, contains: [{ begin: /\\\n/, relevance: 0 }, e2.inherit(s2, { className: "string" }), {
          className: "string",
          begin: /<.*?>/
        }, t2, e2.C_BLOCK_COMMENT_MODE] }, c2 = {
          className: "title",
          begin: n2.optional(a2) + e2.IDENT_RE,
          relevance: 0
        }, d2 = n2.optional(a2) + e2.IDENT_RE + "\\s*\\(", g2 = {
          keyword: ["asm", "auto", "break", "case", "continue", "default", "do", "else", "enum", "extern", "for", "fortran", "goto", "if", "inline", "register", "restrict", "return", "sizeof", "struct", "switch", "typedef", "union", "volatile", "while", "_Alignas", "_Alignof", "_Atomic", "_Generic", "_Noreturn", "_Static_assert", "_Thread_local", "alignas", "alignof", "noreturn", "static_assert", "thread_local", "_Pragma"],
          type: ["float", "double", "signed", "unsigned", "int", "short", "long", "char", "void", "_Bool", "_Complex", "_Imaginary", "_Decimal32", "_Decimal64", "_Decimal128", "const", "static", "complex", "bool", "imaginary"],
          literal: "true false NULL",
          built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
        }, u2 = [l2, r2, t2, e2.C_BLOCK_COMMENT_MODE, o2, s2], b2 = {
          variants: [{ begin: /=/, end: /;/ }, {
            begin: /\(/,
            end: /\)/
          }, { beginKeywords: "new throw return else", end: /;/ }],
          keywords: g2,
          contains: u2.concat([{
            begin: /\(/,
            end: /\)/,
            keywords: g2,
            contains: u2.concat(["self"]),
            relevance: 0
          }]),
          relevance: 0
        }, m2 = {
          begin: "(" + i2 + "[\\*&\\s]+)+" + d2,
          returnBegin: true,
          end: /[{;=]/,
          excludeEnd: true,
          keywords: g2,
          illegal: /[^\w\s\*&:<>.]/,
          contains: [{
            begin: "decltype\\(auto\\)",
            keywords: g2,
            relevance: 0
          }, { begin: d2, returnBegin: true, contains: [e2.inherit(c2, {
            className: "title.function"
          })], relevance: 0 }, { relevance: 0, match: /,/ }, {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: g2,
            relevance: 0,
            contains: [t2, e2.C_BLOCK_COMMENT_MODE, s2, o2, r2, {
              begin: /\(/,
              end: /\)/,
              keywords: g2,
              relevance: 0,
              contains: ["self", t2, e2.C_BLOCK_COMMENT_MODE, s2, o2, r2]
            }]
          }, r2, t2, e2.C_BLOCK_COMMENT_MODE, l2]
        };
        return {
          name: "C",
          aliases: ["h"],
          keywords: g2,
          disableAutodetect: true,
          illegal: "</",
          contains: [].concat(b2, m2, u2, [l2, {
            begin: e2.IDENT_RE + "::",
            keywords: g2
          }, {
            className: "class",
            beginKeywords: "enum class struct union",
            end: /[{;:<>=]/,
            contains: [{
              beginKeywords: "final class struct"
            }, e2.TITLE_MODE]
          }]),
          exports: {
            preprocessor: l2,
            strings: s2,
            keywords: g2
          }
        };
      },
      grmr_cpp: (e2) => {
        const n2 = e2.regex, t2 = e2.COMMENT("//", "$", {
          contains: [{ begin: /\\\n/ }]
        }), a2 = "[a-zA-Z_]\\w*::", i2 = "(?!struct)(decltype\\(auto\\)|" + n2.optional(a2) + "[a-zA-Z_]\\w*" + n2.optional("<[^<>]+>") + ")", r2 = {
          className: "type",
          begin: "\\b[a-z\\d_]*_t\\b"
        }, s2 = { className: "string", variants: [{
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: "\\n",
          contains: [e2.BACKSLASH_ESCAPE]
        }, {
          begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
          end: "'",
          illegal: "."
        }, e2.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/
        })] }, o2 = {
          className: "number",
          variants: [{ begin: "\\b(0b[01']+)" }, {
            begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
          }, {
            begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
          }],
          relevance: 0
        }, l2 = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: {
          keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
        }, contains: [{ begin: /\\\n/, relevance: 0 }, e2.inherit(s2, { className: "string" }), {
          className: "string",
          begin: /<.*?>/
        }, t2, e2.C_BLOCK_COMMENT_MODE] }, c2 = {
          className: "title",
          begin: n2.optional(a2) + e2.IDENT_RE,
          relevance: 0
        }, d2 = n2.optional(a2) + e2.IDENT_RE + "\\s*\\(", g2 = {
          type: ["bool", "char", "char16_t", "char32_t", "char8_t", "double", "float", "int", "long", "short", "void", "wchar_t", "unsigned", "signed", "const", "static"],
          keyword: ["alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor", "break", "case", "catch", "class", "co_await", "co_return", "co_yield", "compl", "concept", "const_cast|10", "consteval", "constexpr", "constinit", "continue", "decltype", "default", "delete", "do", "dynamic_cast|10", "else", "enum", "explicit", "export", "extern", "false", "final", "for", "friend", "goto", "if", "import", "inline", "module", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "override", "private", "protected", "public", "reflexpr", "register", "reinterpret_cast|10", "requires", "return", "sizeof", "static_assert", "static_cast|10", "struct", "switch", "synchronized", "template", "this", "thread_local", "throw", "transaction_safe", "transaction_safe_dynamic", "true", "try", "typedef", "typeid", "typename", "union", "using", "virtual", "volatile", "while", "xor", "xor_eq"],
          literal: ["NULL", "false", "nullopt", "nullptr", "true"],
          built_in: ["_Pragma"],
          _type_hints: ["any", "auto_ptr", "barrier", "binary_semaphore", "bitset", "complex", "condition_variable", "condition_variable_any", "counting_semaphore", "deque", "false_type", "future", "imaginary", "initializer_list", "istringstream", "jthread", "latch", "lock_guard", "multimap", "multiset", "mutex", "optional", "ostringstream", "packaged_task", "pair", "promise", "priority_queue", "queue", "recursive_mutex", "recursive_timed_mutex", "scoped_lock", "set", "shared_future", "shared_lock", "shared_mutex", "shared_timed_mutex", "shared_ptr", "stack", "string_view", "stringstream", "timed_mutex", "thread", "true_type", "tuple", "unique_lock", "unique_ptr", "unordered_map", "unordered_multimap", "unordered_multiset", "unordered_set", "variant", "vector", "weak_ptr", "wstring", "wstring_view"]
        }, u2 = {
          className: "function.dispatch",
          relevance: 0,
          keywords: {
            _hint: ["abort", "abs", "acos", "apply", "as_const", "asin", "atan", "atan2", "calloc", "ceil", "cerr", "cin", "clog", "cos", "cosh", "cout", "declval", "endl", "exchange", "exit", "exp", "fabs", "floor", "fmod", "forward", "fprintf", "fputs", "free", "frexp", "fscanf", "future", "invoke", "isalnum", "isalpha", "iscntrl", "isdigit", "isgraph", "islower", "isprint", "ispunct", "isspace", "isupper", "isxdigit", "labs", "launder", "ldexp", "log", "log10", "make_pair", "make_shared", "make_shared_for_overwrite", "make_tuple", "make_unique", "malloc", "memchr", "memcmp", "memcpy", "memset", "modf", "move", "pow", "printf", "putchar", "puts", "realloc", "scanf", "sin", "sinh", "snprintf", "sprintf", "sqrt", "sscanf", "std", "stderr", "stdin", "stdout", "strcat", "strchr", "strcmp", "strcpy", "strcspn", "strlen", "strncat", "strncmp", "strncpy", "strpbrk", "strrchr", "strspn", "strstr", "swap", "tan", "tanh", "terminate", "to_underlying", "tolower", "toupper", "vfprintf", "visit", "vprintf", "vsprintf"]
          },
          begin: n2.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, e2.IDENT_RE, n2.lookahead(/(<[^<>]+>|)\s*\(/))
        }, b2 = [u2, l2, r2, t2, e2.C_BLOCK_COMMENT_MODE, o2, s2], m2 = {
          variants: [{ begin: /=/, end: /;/ }, {
            begin: /\(/,
            end: /\)/
          }, { beginKeywords: "new throw return else", end: /;/ }],
          keywords: g2,
          contains: b2.concat([{
            begin: /\(/,
            end: /\)/,
            keywords: g2,
            contains: b2.concat(["self"]),
            relevance: 0
          }]),
          relevance: 0
        }, p2 = {
          className: "function",
          begin: "(" + i2 + "[\\*&\\s]+)+" + d2,
          returnBegin: true,
          end: /[{;=]/,
          excludeEnd: true,
          keywords: g2,
          illegal: /[^\w\s\*&:<>.]/,
          contains: [{
            begin: "decltype\\(auto\\)",
            keywords: g2,
            relevance: 0
          }, { begin: d2, returnBegin: true, contains: [c2], relevance: 0 }, {
            begin: /::/,
            relevance: 0
          }, { begin: /:/, endsWithParent: true, contains: [s2, o2] }, {
            relevance: 0,
            match: /,/
          }, {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: g2,
            relevance: 0,
            contains: [t2, e2.C_BLOCK_COMMENT_MODE, s2, o2, r2, {
              begin: /\(/,
              end: /\)/,
              keywords: g2,
              relevance: 0,
              contains: ["self", t2, e2.C_BLOCK_COMMENT_MODE, s2, o2, r2]
            }]
          }, r2, t2, e2.C_BLOCK_COMMENT_MODE, l2]
        };
        return {
          name: "C++",
          aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"],
          keywords: g2,
          illegal: "</",
          classNameAliases: { "function.dispatch": "built_in" },
          contains: [].concat(m2, p2, u2, b2, [l2, {
            begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\s*<(?!<)",
            end: ">",
            keywords: g2,
            contains: ["self", r2]
          }, { begin: e2.IDENT_RE + "::", keywords: g2 }, {
            match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
            className: { 1: "keyword", 3: "title.class" }
          }])
        };
      },
      grmr_csharp: (e2) => {
        const n2 = {
          keyword: ["abstract", "as", "base", "break", "case", "catch", "class", "const", "continue", "do", "else", "event", "explicit", "extern", "finally", "fixed", "for", "foreach", "goto", "if", "implicit", "in", "interface", "internal", "is", "lock", "namespace", "new", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "record", "ref", "return", "scoped", "sealed", "sizeof", "stackalloc", "static", "struct", "switch", "this", "throw", "try", "typeof", "unchecked", "unsafe", "using", "virtual", "void", "volatile", "while"].concat(["add", "alias", "and", "ascending", "async", "await", "by", "descending", "equals", "from", "get", "global", "group", "init", "into", "join", "let", "nameof", "not", "notnull", "on", "or", "orderby", "partial", "remove", "select", "set", "unmanaged", "value|0", "var", "when", "where", "with", "yield"]),
          built_in: ["bool", "byte", "char", "decimal", "delegate", "double", "dynamic", "enum", "float", "int", "long", "nint", "nuint", "object", "sbyte", "short", "string", "ulong", "uint", "ushort"],
          literal: ["default", "false", "null", "true"]
        }, t2 = e2.inherit(e2.TITLE_MODE, {
          begin: "[a-zA-Z](\\.?\\w)*"
        }), a2 = { className: "number", variants: [{
          begin: "\\b(0b[01']+)"
        }, {
          begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)"
        }, {
          begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
        }], relevance: 0 }, i2 = {
          className: "string",
          begin: '@"',
          end: '"',
          contains: [{ begin: '""' }]
        }, r2 = e2.inherit(i2, { illegal: /\n/ }), s2 = {
          className: "subst",
          begin: /\{/,
          end: /\}/,
          keywords: n2
        }, o2 = e2.inherit(s2, { illegal: /\n/ }), l2 = {
          className: "string",
          begin: /\$"/,
          end: '"',
          illegal: /\n/,
          contains: [{ begin: /\{\{/ }, {
            begin: /\}\}/
          }, e2.BACKSLASH_ESCAPE, o2]
        }, c2 = { className: "string", begin: /\$@"/, end: '"', contains: [{
          begin: /\{\{/
        }, { begin: /\}\}/ }, { begin: '""' }, s2] }, d2 = e2.inherit(c2, {
          illegal: /\n/,
          contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, o2]
        });
        s2.contains = [c2, l2, i2, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, a2, e2.C_BLOCK_COMMENT_MODE], o2.contains = [d2, l2, r2, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, a2, e2.inherit(e2.C_BLOCK_COMMENT_MODE, {
          illegal: /\n/
        })];
        const g2 = {
          variants: [c2, l2, i2, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE]
        }, u2 = {
          begin: "<",
          end: ">",
          contains: [{ beginKeywords: "in out" }, t2]
        }, b2 = e2.IDENT_RE + "(<" + e2.IDENT_RE + "(\\s*,\\s*" + e2.IDENT_RE + ")*>)?(\\[\\])?", m2 = {
          begin: "@" + e2.IDENT_RE,
          relevance: 0
        };
        return {
          name: "C#",
          aliases: ["cs", "c#"],
          keywords: n2,
          illegal: /::/,
          contains: [e2.COMMENT("///", "$", {
            returnBegin: true,
            contains: [{ className: "doctag", variants: [{ begin: "///", relevance: 0 }, {
              begin: "<!--|-->"
            }, { begin: "</?", end: ">" }] }]
          }), e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, {
            className: "meta",
            begin: "#",
            end: "$",
            keywords: {
              keyword: "if else elif endif define undef warning error line region endregion pragma checksum"
            }
          }, g2, a2, {
            beginKeywords: "class interface",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [{
              beginKeywords: "where class"
            }, t2, u2, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
          }, {
            beginKeywords: "namespace",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [t2, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
          }, {
            beginKeywords: "record",
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [t2, u2, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
          }, {
            className: "meta",
            begin: "^\\s*\\[(?=[\\w])",
            excludeBegin: true,
            end: "\\]",
            excludeEnd: true,
            contains: [{
              className: "string",
              begin: /"/,
              end: /"/
            }]
          }, {
            beginKeywords: "new return throw await else",
            relevance: 0
          }, {
            className: "function",
            begin: "(" + b2 + "\\s+)+" + e2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: n2,
            contains: [{
              beginKeywords: "public private protected static internal protected abstract async extern override unsafe virtual new sealed partial",
              relevance: 0
            }, {
              begin: e2.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
              returnBegin: true,
              contains: [e2.TITLE_MODE, u2],
              relevance: 0
            }, { match: /\(\)/ }, {
              className: "params",
              begin: /\(/,
              end: /\)/,
              excludeBegin: true,
              excludeEnd: true,
              keywords: n2,
              relevance: 0,
              contains: [g2, a2, e2.C_BLOCK_COMMENT_MODE]
            }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
          }, m2]
        };
      },
      grmr_css: (e2) => {
        const n2 = e2.regex, t2 = te(e2), a2 = [e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE];
        return {
          name: "CSS",
          case_insensitive: true,
          illegal: /[=|'\$]/,
          keywords: {
            keyframePosition: "from to"
          },
          classNameAliases: { keyframePosition: "selector-tag" },
          contains: [t2.BLOCK_COMMENT, {
            begin: /-(webkit|moz|ms|o)-(?=[a-z])/
          }, t2.CSS_NUMBER_MODE, {
            className: "selector-id",
            begin: /#[A-Za-z0-9_-]+/,
            relevance: 0
          }, {
            className: "selector-class",
            begin: "\\.[a-zA-Z-][a-zA-Z0-9_-]*",
            relevance: 0
          }, t2.ATTRIBUTE_SELECTOR_MODE, {
            className: "selector-pseudo",
            variants: [{
              begin: ":(" + re.join("|") + ")"
            }, { begin: ":(:)?(" + se.join("|") + ")" }]
          }, t2.CSS_VARIABLE, { className: "attribute", begin: "\\b(" + oe.join("|") + ")\\b" }, {
            begin: /:/,
            end: /[;}{]/,
            contains: [t2.BLOCK_COMMENT, t2.HEXCOLOR, t2.IMPORTANT, t2.CSS_NUMBER_MODE, ...a2, {
              begin: /(url|data-uri)\(/,
              end: /\)/,
              relevance: 0,
              keywords: {
                built_in: "url data-uri"
              },
              contains: [...a2, {
                className: "string",
                begin: /[^)]/,
                endsWithParent: true,
                excludeEnd: true
              }]
            }, t2.FUNCTION_DISPATCH]
          }, {
            begin: n2.lookahead(/@/),
            end: "[{;]",
            relevance: 0,
            illegal: /:/,
            contains: [{
              className: "keyword",
              begin: /@-?\w[\w]*(-\w+)*/
            }, { begin: /\s/, endsWithParent: true, excludeEnd: true, relevance: 0, keywords: {
              $pattern: /[a-z-]+/,
              keyword: "and or not only",
              attribute: ie.join(" ")
            }, contains: [{
              begin: /[a-z-]+(?=:)/,
              className: "attribute"
            }, ...a2, t2.CSS_NUMBER_MODE] }]
          }, {
            className: "selector-tag",
            begin: "\\b(" + ae.join("|") + ")\\b"
          }]
        };
      },
      grmr_diff: (e2) => {
        const n2 = e2.regex;
        return { name: "Diff", aliases: ["patch"], contains: [{
          className: "meta",
          relevance: 10,
          match: n2.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/, /^\*\*\* +\d+,\d+ +\*\*\*\*$/, /^--- +\d+,\d+ +----$/)
        }, { className: "comment", variants: [{
          begin: n2.either(/Index: /, /^index/, /={3,}/, /^-{3}/, /^\*{3} /, /^\+{3}/, /^diff --git/),
          end: /$/
        }, { match: /^\*{15}$/ }] }, { className: "addition", begin: /^\+/, end: /$/ }, {
          className: "deletion",
          begin: /^-/,
          end: /$/
        }, {
          className: "addition",
          begin: /^!/,
          end: /$/
        }] };
      },
      grmr_go: (e2) => {
        const n2 = {
          keyword: ["break", "case", "chan", "const", "continue", "default", "defer", "else", "fallthrough", "for", "func", "go", "goto", "if", "import", "interface", "map", "package", "range", "return", "select", "struct", "switch", "type", "var"],
          type: ["bool", "byte", "complex64", "complex128", "error", "float32", "float64", "int8", "int16", "int32", "int64", "string", "uint8", "uint16", "uint32", "uint64", "int", "uint", "uintptr", "rune"],
          literal: ["true", "false", "iota", "nil"],
          built_in: ["append", "cap", "close", "complex", "copy", "imag", "len", "make", "new", "panic", "print", "println", "real", "recover", "delete"]
        };
        return {
          name: "Go",
          aliases: ["golang"],
          keywords: n2,
          illegal: "</",
          contains: [e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, {
            className: "string",
            variants: [e2.QUOTE_STRING_MODE, e2.APOS_STRING_MODE, { begin: "`", end: "`" }]
          }, {
            className: "number",
            variants: [{
              begin: e2.C_NUMBER_RE + "[i]",
              relevance: 1
            }, e2.C_NUMBER_MODE]
          }, { begin: /:=/ }, {
            className: "function",
            beginKeywords: "func",
            end: "\\s*(\\{|$)",
            excludeEnd: true,
            contains: [e2.TITLE_MODE, {
              className: "params",
              begin: /\(/,
              end: /\)/,
              endsParent: true,
              keywords: n2,
              illegal: /["']/
            }]
          }]
        };
      },
      grmr_graphql: (e2) => {
        const n2 = e2.regex;
        return {
          name: "GraphQL",
          aliases: ["gql"],
          case_insensitive: true,
          disableAutodetect: false,
          keywords: {
            keyword: ["query", "mutation", "subscription", "type", "input", "schema", "directive", "interface", "union", "scalar", "fragment", "enum", "on"],
            literal: ["true", "false", "null"]
          },
          contains: [e2.HASH_COMMENT_MODE, e2.QUOTE_STRING_MODE, e2.NUMBER_MODE, {
            scope: "punctuation",
            match: /[.]{3}/,
            relevance: 0
          }, {
            scope: "punctuation",
            begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
            relevance: 0
          }, {
            scope: "variable",
            begin: /\$/,
            end: /\W/,
            excludeEnd: true,
            relevance: 0
          }, { scope: "meta", match: /@\w+/, excludeEnd: true }, {
            scope: "symbol",
            begin: n2.concat(/[_A-Za-z][_0-9A-Za-z]*/, n2.lookahead(/\s*:/)),
            relevance: 0
          }],
          illegal: [/[;<']/, /BEGIN/]
        };
      },
      grmr_ini: (e2) => {
        const n2 = e2.regex, t2 = {
          className: "number",
          relevance: 0,
          variants: [{ begin: /([+-]+)?[\d]+_[\d_]+/ }, {
            begin: e2.NUMBER_RE
          }]
        }, a2 = e2.COMMENT();
        a2.variants = [{ begin: /;/, end: /$/ }, {
          begin: /#/,
          end: /$/
        }];
        const i2 = { className: "variable", variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, {
          begin: /\$\{(.*?)\}/
        }] }, r2 = {
          className: "literal",
          begin: /\bon|off|true|false|yes|no\b/
        }, s2 = {
          className: "string",
          contains: [e2.BACKSLASH_ESCAPE],
          variants: [{ begin: "'''", end: "'''", relevance: 10 }, {
            begin: '"""',
            end: '"""',
            relevance: 10
          }, { begin: '"', end: '"' }, { begin: "'", end: "'" }]
        }, o2 = {
          begin: /\[/,
          end: /\]/,
          contains: [a2, r2, i2, s2, t2, "self"],
          relevance: 0
        }, l2 = n2.either(/[A-Za-z0-9_-]+/, /"(\\"|[^"])*"/, /'[^']*'/);
        return {
          name: "TOML, also INI",
          aliases: ["toml"],
          case_insensitive: true,
          illegal: /\S/,
          contains: [a2, { className: "section", begin: /\[+/, end: /\]+/ }, {
            begin: n2.concat(l2, "(\\s*\\.\\s*", l2, ")*", n2.lookahead(/\s*=\s*[^#\s]/)),
            className: "attr",
            starts: { end: /$/, contains: [a2, o2, r2, i2, s2, t2] }
          }]
        };
      },
      grmr_java: (e2) => {
        const n2 = e2.regex, t2 = "[\xC0-\u02B8a-zA-Z_$][\xC0-\u02B8a-zA-Z_$0-9]*", a2 = t2 + ue("(?:<" + t2 + "~~~(?:\\s*,\\s*" + t2 + "~~~)*>)?", /~~~/g, 2), i2 = {
          keyword: ["synchronized", "abstract", "private", "var", "static", "if", "const ", "for", "while", "strictfp", "finally", "protected", "import", "native", "final", "void", "enum", "else", "break", "transient", "catch", "instanceof", "volatile", "case", "assert", "package", "default", "public", "try", "switch", "continue", "throws", "protected", "public", "private", "module", "requires", "exports", "do", "sealed", "yield", "permits"],
          literal: ["false", "true", "null"],
          type: ["char", "boolean", "long", "float", "int", "byte", "short", "double"],
          built_in: ["super", "this"]
        }, r2 = { className: "meta", begin: "@" + t2, contains: [{
          begin: /\(/,
          end: /\)/,
          contains: ["self"]
        }] }, s2 = {
          className: "params",
          begin: /\(/,
          end: /\)/,
          keywords: i2,
          relevance: 0,
          contains: [e2.C_BLOCK_COMMENT_MODE],
          endsParent: true
        };
        return {
          name: "Java",
          aliases: ["jsp"],
          keywords: i2,
          illegal: /<\/|#/,
          contains: [e2.COMMENT("/\\*\\*", "\\*/", { relevance: 0, contains: [{
            begin: /\w+@/,
            relevance: 0
          }, { className: "doctag", begin: "@[A-Za-z]+" }] }), {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, {
            begin: /"""/,
            end: /"""/,
            className: "string",
            contains: [e2.BACKSLASH_ESCAPE]
          }, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, {
            match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, t2],
            className: {
              1: "keyword",
              3: "title.class"
            }
          }, { match: /non-sealed/, scope: "keyword" }, {
            begin: [n2.concat(/(?!else)/, t2), /\s+/, t2, /\s+/, /=(?!=)/],
            className: {
              1: "type",
              3: "variable",
              5: "operator"
            }
          }, { begin: [/record/, /\s+/, t2], className: {
            1: "keyword",
            3: "title.class"
          }, contains: [s2, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE] }, {
            beginKeywords: "new throw return else",
            relevance: 0
          }, {
            begin: ["(?:" + a2 + "\\s+)", e2.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
            className: {
              2: "title.function"
            },
            keywords: i2,
            contains: [{
              className: "params",
              begin: /\(/,
              end: /\)/,
              keywords: i2,
              relevance: 0,
              contains: [r2, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, ge, e2.C_BLOCK_COMMENT_MODE]
            }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
          }, ge, r2]
        };
      },
      grmr_javascript: we,
      grmr_json: (e2) => {
        const n2 = ["true", "false", "null"], t2 = {
          scope: "literal",
          beginKeywords: n2.join(" ")
        };
        return {
          name: "JSON",
          keywords: { literal: n2 },
          contains: [{
            className: "attr",
            begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
            relevance: 1.01
          }, {
            match: /[{}[\],:]/,
            className: "punctuation",
            relevance: 0
          }, e2.QUOTE_STRING_MODE, t2, e2.C_NUMBER_MODE, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE],
          illegal: "\\S"
        };
      },
      grmr_kotlin: (e2) => {
        const n2 = {
          keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
          built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
          literal: "true false null"
        }, t2 = {
          className: "symbol",
          begin: e2.UNDERSCORE_IDENT_RE + "@"
        }, a2 = { className: "subst", begin: /\$\{/, end: /\}/, contains: [e2.C_NUMBER_MODE] }, i2 = {
          className: "variable",
          begin: "\\$" + e2.UNDERSCORE_IDENT_RE
        }, r2 = {
          className: "string",
          variants: [{ begin: '"""', end: '"""(?=[^"])', contains: [i2, a2] }, {
            begin: "'",
            end: "'",
            illegal: /\n/,
            contains: [e2.BACKSLASH_ESCAPE]
          }, {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [e2.BACKSLASH_ESCAPE, i2, a2]
          }]
        };
        a2.contains.push(r2);
        const s2 = {
          className: "meta",
          begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + e2.UNDERSCORE_IDENT_RE + ")?"
        }, o2 = {
          className: "meta",
          begin: "@" + e2.UNDERSCORE_IDENT_RE,
          contains: [{
            begin: /\(/,
            end: /\)/,
            contains: [e2.inherit(r2, { className: "string" }), "self"]
          }]
        }, l2 = ge, c2 = e2.COMMENT("/\\*", "\\*/", { contains: [e2.C_BLOCK_COMMENT_MODE] }), d2 = {
          variants: [{ className: "type", begin: e2.UNDERSCORE_IDENT_RE }, {
            begin: /\(/,
            end: /\)/,
            contains: []
          }]
        }, g2 = d2;
        return g2.variants[1].contains = [d2], d2.variants[1].contains = [g2], {
          name: "Kotlin",
          aliases: ["kt", "kts"],
          keywords: n2,
          contains: [e2.COMMENT("/\\*\\*", "\\*/", { relevance: 0, contains: [{
            className: "doctag",
            begin: "@[A-Za-z]+"
          }] }), e2.C_LINE_COMMENT_MODE, c2, {
            className: "keyword",
            begin: /\b(break|continue|return|this)\b/,
            starts: { contains: [{
              className: "symbol",
              begin: /@\w+/
            }] }
          }, t2, s2, o2, {
            className: "function",
            beginKeywords: "fun",
            end: "[(]|$",
            returnBegin: true,
            excludeEnd: true,
            keywords: n2,
            relevance: 5,
            contains: [{
              begin: e2.UNDERSCORE_IDENT_RE + "\\s*\\(",
              returnBegin: true,
              relevance: 0,
              contains: [e2.UNDERSCORE_TITLE_MODE]
            }, {
              className: "type",
              begin: /</,
              end: />/,
              keywords: "reified",
              relevance: 0
            }, {
              className: "params",
              begin: /\(/,
              end: /\)/,
              endsParent: true,
              keywords: n2,
              relevance: 0,
              contains: [{
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: true,
                contains: [d2, e2.C_LINE_COMMENT_MODE, c2],
                relevance: 0
              }, e2.C_LINE_COMMENT_MODE, c2, s2, o2, r2, e2.C_NUMBER_MODE]
            }, c2]
          }, {
            begin: [/class|interface|trait/, /\s+/, e2.UNDERSCORE_IDENT_RE],
            beginScope: {
              3: "title.class"
            },
            keywords: "class interface trait",
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: "extends implements",
            contains: [{
              beginKeywords: "public protected internal private constructor"
            }, e2.UNDERSCORE_TITLE_MODE, {
              className: "type",
              begin: /</,
              end: />/,
              excludeBegin: true,
              excludeEnd: true,
              relevance: 0
            }, {
              className: "type",
              begin: /[,:]\s*/,
              end: /[<\(,){\s]|$/,
              excludeBegin: true,
              returnEnd: true
            }, s2, o2]
          }, r2, {
            className: "meta",
            begin: "^#!/usr/bin/env",
            end: "$",
            illegal: "\n"
          }, l2]
        };
      },
      grmr_less: (e2) => {
        const n2 = te(e2), t2 = le, a2 = "([\\w-]+|@\\{[\\w-]+\\})", i2 = [], r2 = [], s2 = (e3) => ({
          className: "string",
          begin: "~?" + e3 + ".*?" + e3
        }), o2 = (e3, n3, t3) => ({
          className: e3,
          begin: n3,
          relevance: t3
        }), l2 = {
          $pattern: /[a-z-]+/,
          keyword: "and or not only",
          attribute: ie.join(" ")
        }, c2 = {
          begin: "\\(",
          end: "\\)",
          contains: r2,
          keywords: l2,
          relevance: 0
        };
        r2.push(e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, s2("'"), s2('"'), n2.CSS_NUMBER_MODE, {
          begin: "(url|data-uri)\\(",
          starts: {
            className: "string",
            end: "[\\)\\n]",
            excludeEnd: true
          }
        }, n2.HEXCOLOR, c2, o2("variable", "@@?[\\w-]+", 10), o2("variable", "@\\{[\\w-]+\\}"), o2("built_in", "~?`[^`]*?`"), {
          className: "attribute",
          begin: "[\\w-]+\\s*:",
          end: ":",
          returnBegin: true,
          excludeEnd: true
        }, n2.IMPORTANT, { beginKeywords: "and not" }, n2.FUNCTION_DISPATCH);
        const d2 = r2.concat({
          begin: /\{/,
          end: /\}/,
          contains: i2
        }), g2 = {
          beginKeywords: "when",
          endsWithParent: true,
          contains: [{ beginKeywords: "and not" }].concat(r2)
        }, u2 = {
          begin: a2 + "\\s*:",
          returnBegin: true,
          end: /[;}]/,
          relevance: 0,
          contains: [{
            begin: /-(webkit|moz|ms|o)-/
          }, n2.CSS_VARIABLE, {
            className: "attribute",
            begin: "\\b(" + oe.join("|") + ")\\b",
            end: /(?=:)/,
            starts: { endsWithParent: true, illegal: "[<=$]", relevance: 0, contains: r2 }
          }]
        }, b2 = {
          className: "keyword",
          begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
          starts: { end: "[;{}]", keywords: l2, returnEnd: true, contains: r2, relevance: 0 }
        }, m2 = {
          className: "variable",
          variants: [{ begin: "@[\\w-]+\\s*:", relevance: 15 }, {
            begin: "@[\\w-]+"
          }],
          starts: { end: "[;}]", returnEnd: true, contains: d2 }
        }, p2 = {
          variants: [{
            begin: "[\\.#:&\\[>]",
            end: "[;{}]"
          }, { begin: a2, end: /\{/ }],
          returnBegin: true,
          returnEnd: true,
          illegal: "[<='$\"]",
          relevance: 0,
          contains: [e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, g2, o2("keyword", "all\\b"), o2("variable", "@\\{[\\w-]+\\}"), {
            begin: "\\b(" + ae.join("|") + ")\\b",
            className: "selector-tag"
          }, n2.CSS_NUMBER_MODE, o2("selector-tag", a2, 0), o2("selector-id", "#" + a2), o2("selector-class", "\\." + a2, 0), o2("selector-tag", "&", 0), n2.ATTRIBUTE_SELECTOR_MODE, {
            className: "selector-pseudo",
            begin: ":(" + re.join("|") + ")"
          }, {
            className: "selector-pseudo",
            begin: ":(:)?(" + se.join("|") + ")"
          }, {
            begin: /\(/,
            end: /\)/,
            relevance: 0,
            contains: d2
          }, { begin: "!important" }, n2.FUNCTION_DISPATCH]
        }, _2 = {
          begin: `[\\w-]+:(:)?(${t2.join("|")})`,
          returnBegin: true,
          contains: [p2]
        };
        return i2.push(e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, b2, m2, _2, u2, p2, g2, n2.FUNCTION_DISPATCH), { name: "Less", case_insensitive: true, illegal: "[=>'/<($\"]", contains: i2 };
      },
      grmr_lua: (e2) => {
        const n2 = "\\[=*\\[", t2 = "\\]=*\\]", a2 = {
          begin: n2,
          end: t2,
          contains: ["self"]
        }, i2 = [e2.COMMENT("--(?!\\[=*\\[)", "$"), e2.COMMENT("--\\[=*\\[", t2, {
          contains: [a2],
          relevance: 10
        })];
        return { name: "Lua", keywords: {
          $pattern: e2.UNDERSCORE_IDENT_RE,
          literal: "true false nil",
          keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
          built_in: "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
        }, contains: i2.concat([{
          className: "function",
          beginKeywords: "function",
          end: "\\)",
          contains: [e2.inherit(e2.TITLE_MODE, {
            begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*"
          }), {
            className: "params",
            begin: "\\(",
            endsWithParent: true,
            contains: i2
          }].concat(i2)
        }, e2.C_NUMBER_MODE, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE, {
          className: "string",
          begin: n2,
          end: t2,
          contains: [a2],
          relevance: 5
        }]) };
      },
      grmr_makefile: (e2) => {
        const n2 = {
          className: "variable",
          variants: [{
            begin: "\\$\\(" + e2.UNDERSCORE_IDENT_RE + "\\)",
            contains: [e2.BACKSLASH_ESCAPE]
          }, { begin: /\$[@%<?\^\+\*]/ }]
        }, t2 = {
          className: "string",
          begin: /"/,
          end: /"/,
          contains: [e2.BACKSLASH_ESCAPE, n2]
        }, a2 = {
          className: "variable",
          begin: /\$\([\w-]+\s/,
          end: /\)/,
          keywords: {
            built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value"
          },
          contains: [n2]
        }, i2 = { begin: "^" + e2.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, r2 = {
          className: "section",
          begin: /^[^\s]+:/,
          end: /$/,
          contains: [n2]
        };
        return {
          name: "Makefile",
          aliases: ["mk", "mak", "make"],
          keywords: {
            $pattern: /[\w-]+/,
            keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
          },
          contains: [e2.HASH_COMMENT_MODE, n2, t2, a2, i2, {
            className: "meta",
            begin: /^\.PHONY:/,
            end: /$/,
            keywords: { $pattern: /[\.\w]+/, keyword: ".PHONY" }
          }, r2]
        };
      },
      grmr_xml: (e2) => {
        const n2 = e2.regex, t2 = n2.concat(/[\p{L}_]/u, n2.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), a2 = {
          className: "symbol",
          begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
        }, i2 = {
          begin: /\s/,
          contains: [{ className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }]
        }, r2 = e2.inherit(i2, { begin: /\(/, end: /\)/ }), s2 = e2.inherit(e2.APOS_STRING_MODE, {
          className: "string"
        }), o2 = e2.inherit(e2.QUOTE_STRING_MODE, { className: "string" }), l2 = {
          endsWithParent: true,
          illegal: /</,
          relevance: 0,
          contains: [{
            className: "attr",
            begin: /[\p{L}0-9._:-]+/u,
            relevance: 0
          }, { begin: /=\s*/, relevance: 0, contains: [{
            className: "string",
            endsParent: true,
            variants: [{ begin: /"/, end: /"/, contains: [a2] }, {
              begin: /'/,
              end: /'/,
              contains: [a2]
            }, { begin: /[^\s"'=<>`]+/ }]
          }] }]
        };
        return {
          name: "HTML, XML",
          aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"],
          case_insensitive: true,
          unicodeRegex: true,
          contains: [{
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [i2, o2, s2, r2, { begin: /\[/, end: /\]/, contains: [{
              className: "meta",
              begin: /<![a-z]/,
              end: />/,
              contains: [i2, r2, o2, s2]
            }] }]
          }, e2.COMMENT(/<!--/, /-->/, { relevance: 10 }), {
            begin: /<!\[CDATA\[/,
            end: /\]\]>/,
            relevance: 10
          }, a2, { className: "meta", end: /\?>/, variants: [{
            begin: /<\?xml/,
            relevance: 10,
            contains: [o2]
          }, { begin: /<\?[a-z][a-z0-9]+/ }] }, {
            className: "tag",
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: { name: "style" },
            contains: [l2],
            starts: {
              end: /<\/style>/,
              returnEnd: true,
              subLanguage: ["css", "xml"]
            }
          }, {
            className: "tag",
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: { name: "script" },
            contains: [l2],
            starts: {
              end: /<\/script>/,
              returnEnd: true,
              subLanguage: ["javascript", "handlebars", "xml"]
            }
          }, {
            className: "tag",
            begin: /<>|<\/>/
          }, {
            className: "tag",
            begin: n2.concat(/</, n2.lookahead(n2.concat(t2, n2.either(/\/>/, />/, /\s/)))),
            end: /\/?>/,
            contains: [{ className: "name", begin: t2, relevance: 0, starts: l2 }]
          }, {
            className: "tag",
            begin: n2.concat(/<\//, n2.lookahead(n2.concat(t2, />/))),
            contains: [{
              className: "name",
              begin: t2,
              relevance: 0
            }, { begin: />/, relevance: 0, endsParent: true }]
          }]
        };
      },
      grmr_markdown: (e2) => {
        const n2 = {
          begin: /<\/?[A-Za-z_]/,
          end: ">",
          subLanguage: "xml",
          relevance: 0
        }, t2 = { variants: [{ begin: /\[.+?\]\[.*?\]/, relevance: 0 }, {
          begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
          relevance: 2
        }, {
          begin: e2.regex.concat(/\[.+?\]\(/, /[A-Za-z][A-Za-z0-9+.-]*/, /:\/\/.*?\)/),
          relevance: 2
        }, { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 }, {
          begin: /\[.*?\]\(.*?\)/,
          relevance: 0
        }], returnBegin: true, contains: [{
          match: /\[(?=\])/
        }, {
          className: "string",
          relevance: 0,
          begin: "\\[",
          end: "\\]",
          excludeBegin: true,
          returnEnd: true
        }, {
          className: "link",
          relevance: 0,
          begin: "\\]\\(",
          end: "\\)",
          excludeBegin: true,
          excludeEnd: true
        }, {
          className: "symbol",
          relevance: 0,
          begin: "\\]\\[",
          end: "\\]",
          excludeBegin: true,
          excludeEnd: true
        }] }, a2 = {
          className: "strong",
          contains: [],
          variants: [{ begin: /_{2}(?!\s)/, end: /_{2}/ }, { begin: /\*{2}(?!\s)/, end: /\*{2}/ }]
        }, i2 = { className: "emphasis", contains: [], variants: [{ begin: /\*(?![*\s])/, end: /\*/ }, {
          begin: /_(?![_\s])/,
          end: /_/,
          relevance: 0
        }] }, r2 = e2.inherit(a2, {
          contains: []
        }), s2 = e2.inherit(i2, { contains: [] });
        a2.contains.push(s2), i2.contains.push(r2);
        let o2 = [n2, t2];
        return [a2, i2, r2, s2].forEach((e3) => {
          e3.contains = e3.contains.concat(o2);
        }), o2 = o2.concat(a2, i2), { name: "Markdown", aliases: ["md", "mkdown", "mkd"], contains: [{
          className: "section",
          variants: [{ begin: "^#{1,6}", end: "$", contains: o2 }, {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [{ begin: "^[=-]*$" }, {
              begin: "^",
              end: "\\n",
              contains: o2
            }]
          }]
        }, n2, {
          className: "bullet",
          begin: "^[ \t]*([*+-]|(\\d+\\.))(?=\\s+)",
          end: "\\s+",
          excludeEnd: true
        }, a2, i2, {
          className: "quote",
          begin: "^>\\s+",
          contains: o2,
          end: "$"
        }, { className: "code", variants: [{ begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" }, {
          begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*"
        }, { begin: "```", end: "```+[ ]*$" }, {
          begin: "~~~",
          end: "~~~+[ ]*$"
        }, { begin: "`.+?`" }, {
          begin: "(?=^( {4}|\\t))",
          contains: [{ begin: "^( {4}|\\t)", end: "(\\n)$" }],
          relevance: 0
        }] }, {
          begin: "^[-\\*]{3,}",
          end: "$"
        }, t2, { begin: /^\[[^\n]+\]:/, returnBegin: true, contains: [{
          className: "symbol",
          begin: /\[/,
          end: /\]/,
          excludeBegin: true,
          excludeEnd: true
        }, {
          className: "link",
          begin: /:\s*/,
          end: /$/,
          excludeBegin: true
        }] }] };
      },
      grmr_objectivec: (e2) => {
        const n2 = /[a-zA-Z@][a-zA-Z0-9_]*/, t2 = {
          $pattern: n2,
          keyword: ["@interface", "@class", "@protocol", "@implementation"]
        };
        return {
          name: "Objective-C",
          aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"],
          keywords: {
            "variable.language": ["this", "super"],
            $pattern: n2,
            keyword: ["while", "export", "sizeof", "typedef", "const", "struct", "for", "union", "volatile", "static", "mutable", "if", "do", "return", "goto", "enum", "else", "break", "extern", "asm", "case", "default", "register", "explicit", "typename", "switch", "continue", "inline", "readonly", "assign", "readwrite", "self", "@synchronized", "id", "typeof", "nonatomic", "IBOutlet", "IBAction", "strong", "weak", "copy", "in", "out", "inout", "bycopy", "byref", "oneway", "__strong", "__weak", "__block", "__autoreleasing", "@private", "@protected", "@public", "@try", "@property", "@end", "@throw", "@catch", "@finally", "@autoreleasepool", "@synthesize", "@dynamic", "@selector", "@optional", "@required", "@encode", "@package", "@import", "@defs", "@compatibility_alias", "__bridge", "__bridge_transfer", "__bridge_retained", "__bridge_retain", "__covariant", "__contravariant", "__kindof", "_Nonnull", "_Nullable", "_Null_unspecified", "__FUNCTION__", "__PRETTY_FUNCTION__", "__attribute__", "getter", "setter", "retain", "unsafe_unretained", "nonnull", "nullable", "null_unspecified", "null_resettable", "class", "instancetype", "NS_DESIGNATED_INITIALIZER", "NS_UNAVAILABLE", "NS_REQUIRES_SUPER", "NS_RETURNS_INNER_POINTER", "NS_INLINE", "NS_AVAILABLE", "NS_DEPRECATED", "NS_ENUM", "NS_OPTIONS", "NS_SWIFT_UNAVAILABLE", "NS_ASSUME_NONNULL_BEGIN", "NS_ASSUME_NONNULL_END", "NS_REFINED_FOR_SWIFT", "NS_SWIFT_NAME", "NS_SWIFT_NOTHROW", "NS_DURING", "NS_HANDLER", "NS_ENDHANDLER", "NS_VALUERETURN", "NS_VOIDRETURN"],
            literal: ["false", "true", "FALSE", "TRUE", "nil", "YES", "NO", "NULL"],
            built_in: ["dispatch_once_t", "dispatch_queue_t", "dispatch_sync", "dispatch_async", "dispatch_once"],
            type: ["int", "float", "char", "unsigned", "signed", "short", "long", "double", "wchar_t", "unichar", "void", "bool", "BOOL", "id|0", "_Bool"]
          },
          illegal: "</",
          contains: [{
            className: "built_in",
            begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
          }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, e2.C_NUMBER_MODE, e2.QUOTE_STRING_MODE, e2.APOS_STRING_MODE, {
            className: "string",
            variants: [{
              begin: '@"',
              end: '"',
              illegal: "\\n",
              contains: [e2.BACKSLASH_ESCAPE]
            }]
          }, {
            className: "meta",
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: {
              keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include"
            },
            contains: [{ begin: /\\\n/, relevance: 0 }, e2.inherit(e2.QUOTE_STRING_MODE, {
              className: "string"
            }), {
              className: "string",
              begin: /<.*?>/,
              end: /$/,
              illegal: "\\n"
            }, e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE]
          }, {
            className: "class",
            begin: "(" + t2.keyword.join("|") + ")\\b",
            end: /(\{|$)/,
            excludeEnd: true,
            keywords: t2,
            contains: [e2.UNDERSCORE_TITLE_MODE]
          }, {
            begin: "\\." + e2.UNDERSCORE_IDENT_RE,
            relevance: 0
          }]
        };
      },
      grmr_perl: (e2) => {
        const n2 = e2.regex, t2 = /[dualxmsipngr]{0,12}/, a2 = {
          $pattern: /[\w.]+/,
          keyword: "abs accept alarm and atan2 bind binmode bless break caller chdir chmod chomp chop chown chr chroot close closedir connect continue cos crypt dbmclose dbmopen defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent eof eval exec exists exit exp fcntl fileno flock for foreach fork format formline getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt given glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst length link listen local localtime log lstat lt ma map mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord our pack package pipe pop pos print printf prototype push q|0 qq quotemeta qw qx rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir say scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat state study sub substr symlink syscall sysopen sysread sysseek system syswrite tell telldir tie tied time times tr truncate uc ucfirst umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray warn when while write x|0 xor y|0"
        }, i2 = { className: "subst", begin: "[$@]\\{", end: "\\}", keywords: a2 }, r2 = {
          begin: /->\{/,
          end: /\}/
        }, s2 = {
          variants: [{ begin: /\$\d/ }, {
            begin: n2.concat(/[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/, "(?![A-Za-z])(?![@$%])")
          }, { begin: /[$%@][^\s\w{]/, relevance: 0 }]
        }, o2 = [e2.BACKSLASH_ESCAPE, i2, s2], l2 = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/], c2 = (e3, a3, i3 = "\\1") => {
          const r3 = i3 === "\\1" ? i3 : n2.concat(i3, a3);
          return n2.concat(n2.concat("(?:", e3, ")"), a3, /(?:\\.|[^\\\/])*?/, r3, /(?:\\.|[^\\\/])*?/, i3, t2);
        }, d2 = (e3, a3, i3) => n2.concat(n2.concat("(?:", e3, ")"), a3, /(?:\\.|[^\\\/])*?/, i3, t2), g2 = [s2, e2.HASH_COMMENT_MODE, e2.COMMENT(/^=\w/, /=cut/, {
          endsWithParent: true
        }), r2, { className: "string", contains: o2, variants: [{
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        }, {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        }, { begin: "q[qwxr]?\\s*\\{", end: "\\}", relevance: 5 }, {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        }, {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        }, { begin: "qw\\s+q", end: "q", relevance: 5 }, {
          begin: "'",
          end: "'",
          contains: [e2.BACKSLASH_ESCAPE]
        }, { begin: '"', end: '"' }, {
          begin: "`",
          end: "`",
          contains: [e2.BACKSLASH_ESCAPE]
        }, { begin: /\{\w+\}/, relevance: 0 }, {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }] }, {
          className: "number",
          begin: "(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",
          relevance: 0
        }, {
          begin: "(\\/\\/|" + e2.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
          keywords: "split return print reverse grep",
          relevance: 0,
          contains: [e2.HASH_COMMENT_MODE, { className: "regexp", variants: [{
            begin: c2("s|tr|y", n2.either(...l2, { capture: true }))
          }, { begin: c2("s|tr|y", "\\(", "\\)") }, {
            begin: c2("s|tr|y", "\\[", "\\]")
          }, { begin: c2("s|tr|y", "\\{", "\\}") }], relevance: 2 }, {
            className: "regexp",
            variants: [{ begin: /(m|qr)\/\//, relevance: 0 }, {
              begin: d2("(?:m|qr)?", /\//, /\//)
            }, { begin: d2("m|qr", n2.either(...l2, {
              capture: true
            }), /\1/) }, { begin: d2("m|qr", /\(/, /\)/) }, { begin: d2("m|qr", /\[/, /\]/) }, {
              begin: d2("m|qr", /\{/, /\}/)
            }]
          }]
        }, {
          className: "function",
          beginKeywords: "sub",
          end: "(\\s*\\(.*?\\))?[;{]",
          excludeEnd: true,
          relevance: 5,
          contains: [e2.TITLE_MODE]
        }, {
          begin: "-\\w\\b",
          relevance: 0
        }, {
          begin: "^__DATA__$",
          end: "^__END__$",
          subLanguage: "mojolicious",
          contains: [{ begin: "^@@.*", end: "$", className: "comment" }]
        }];
        return i2.contains = g2, r2.contains = g2, {
          name: "Perl",
          aliases: ["pl", "pm"],
          keywords: a2,
          contains: g2
        };
      },
      grmr_php: (e2) => {
        const n2 = e2.regex, t2 = /(?![A-Za-z0-9])(?![$])/, a2 = n2.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, t2), i2 = n2.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, t2), r2 = {
          scope: "variable",
          match: "\\$+" + a2
        }, s2 = { scope: "subst", variants: [{ begin: /\$\w+/ }, {
          begin: /\{\$/,
          end: /\}/
        }] }, o2 = e2.inherit(e2.APOS_STRING_MODE, {
          illegal: null
        }), l2 = "[ \t\n]", c2 = { scope: "string", variants: [e2.inherit(e2.QUOTE_STRING_MODE, {
          illegal: null,
          contains: e2.QUOTE_STRING_MODE.contains.concat(s2)
        }), o2, e2.END_SAME_AS_BEGIN({
          begin: /<<<[ \t]*(\w+)\n/,
          end: /[ \t]*(\w+)\b/,
          contains: e2.QUOTE_STRING_MODE.contains.concat(s2)
        })] }, d2 = {
          scope: "number",
          variants: [{ begin: "\\b0[bB][01]+(?:_[01]+)*\\b" }, {
            begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b"
          }, {
            begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b"
          }, {
            begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?"
          }],
          relevance: 0
        }, g2 = ["false", "null", "true"], u2 = ["__CLASS__", "__DIR__", "__FILE__", "__FUNCTION__", "__COMPILER_HALT_OFFSET__", "__LINE__", "__METHOD__", "__NAMESPACE__", "__TRAIT__", "die", "echo", "exit", "include", "include_once", "print", "require", "require_once", "array", "abstract", "and", "as", "binary", "bool", "boolean", "break", "callable", "case", "catch", "class", "clone", "const", "continue", "declare", "default", "do", "double", "else", "elseif", "empty", "enddeclare", "endfor", "endforeach", "endif", "endswitch", "endwhile", "enum", "eval", "extends", "final", "finally", "float", "for", "foreach", "from", "global", "goto", "if", "implements", "instanceof", "insteadof", "int", "integer", "interface", "isset", "iterable", "list", "match|0", "mixed", "new", "never", "object", "or", "private", "protected", "public", "readonly", "real", "return", "string", "switch", "throw", "trait", "try", "unset", "use", "var", "void", "while", "xor", "yield"], b2 = ["Error|0", "AppendIterator", "ArgumentCountError", "ArithmeticError", "ArrayIterator", "ArrayObject", "AssertionError", "BadFunctionCallException", "BadMethodCallException", "CachingIterator", "CallbackFilterIterator", "CompileError", "Countable", "DirectoryIterator", "DivisionByZeroError", "DomainException", "EmptyIterator", "ErrorException", "Exception", "FilesystemIterator", "FilterIterator", "GlobIterator", "InfiniteIterator", "InvalidArgumentException", "IteratorIterator", "LengthException", "LimitIterator", "LogicException", "MultipleIterator", "NoRewindIterator", "OutOfBoundsException", "OutOfRangeException", "OuterIterator", "OverflowException", "ParentIterator", "ParseError", "RangeException", "RecursiveArrayIterator", "RecursiveCachingIterator", "RecursiveCallbackFilterIterator", "RecursiveDirectoryIterator", "RecursiveFilterIterator", "RecursiveIterator", "RecursiveIteratorIterator", "RecursiveRegexIterator", "RecursiveTreeIterator", "RegexIterator", "RuntimeException", "SeekableIterator", "SplDoublyLinkedList", "SplFileInfo", "SplFileObject", "SplFixedArray", "SplHeap", "SplMaxHeap", "SplMinHeap", "SplObjectStorage", "SplObserver", "SplPriorityQueue", "SplQueue", "SplStack", "SplSubject", "SplTempFileObject", "TypeError", "UnderflowException", "UnexpectedValueException", "UnhandledMatchError", "ArrayAccess", "BackedEnum", "Closure", "Fiber", "Generator", "Iterator", "IteratorAggregate", "Serializable", "Stringable", "Throwable", "Traversable", "UnitEnum", "WeakReference", "WeakMap", "Directory", "__PHP_Incomplete_Class", "parent", "php_user_filter", "self", "static", "stdClass"], m2 = {
          keyword: u2,
          literal: ((e3) => {
            const n3 = [];
            return e3.forEach((e4) => {
              n3.push(e4), e4.toLowerCase() === e4 ? n3.push(e4.toUpperCase()) : n3.push(e4.toLowerCase());
            }), n3;
          })(g2),
          built_in: b2
        }, p2 = (e3) => e3.map((e4) => e4.replace(/\|\d+$/, "")), _2 = { variants: [{
          match: [/new/, n2.concat(l2, "+"), n2.concat("(?!", p2(b2).join("\\b|"), "\\b)"), i2],
          scope: {
            1: "keyword",
            4: "title.class"
          }
        }] }, h2 = n2.concat(a2, "\\b(?!\\()"), f2 = { variants: [{
          match: [n2.concat(/::/, n2.lookahead(/(?!class\b)/)), h2],
          scope: {
            2: "variable.constant"
          }
        }, { match: [/::/, /class/], scope: { 2: "variable.language" } }, {
          match: [i2, n2.concat(/::/, n2.lookahead(/(?!class\b)/)), h2],
          scope: {
            1: "title.class",
            3: "variable.constant"
          }
        }, {
          match: [i2, n2.concat("::", n2.lookahead(/(?!class\b)/))],
          scope: { 1: "title.class" }
        }, { match: [i2, /::/, /class/], scope: {
          1: "title.class",
          3: "variable.language"
        } }] }, E2 = {
          scope: "attr",
          match: n2.concat(a2, n2.lookahead(":"), n2.lookahead(/(?!::)/))
        }, y2 = {
          relevance: 0,
          begin: /\(/,
          end: /\)/,
          keywords: m2,
          contains: [E2, r2, f2, e2.C_BLOCK_COMMENT_MODE, c2, d2, _2]
        }, w2 = {
          relevance: 0,
          match: [/\b/, n2.concat("(?!fn\\b|function\\b|", p2(u2).join("\\b|"), "|", p2(b2).join("\\b|"), "\\b)"), a2, n2.concat(l2, "*"), n2.lookahead(/(?=\()/)],
          scope: { 3: "title.function.invoke" },
          contains: [y2]
        };
        y2.contains.push(w2);
        const N2 = [E2, f2, e2.C_BLOCK_COMMENT_MODE, c2, d2, _2];
        return {
          case_insensitive: false,
          keywords: m2,
          contains: [{
            begin: n2.concat(/#\[\s*/, i2),
            beginScope: "meta",
            end: /]/,
            endScope: "meta",
            keywords: { literal: g2, keyword: ["new", "array"] },
            contains: [{
              begin: /\[/,
              end: /]/,
              keywords: { literal: g2, keyword: ["new", "array"] },
              contains: ["self", ...N2]
            }, ...N2, { scope: "meta", match: i2 }]
          }, e2.HASH_COMMENT_MODE, e2.COMMENT("//", "$"), e2.COMMENT("/\\*", "\\*/", { contains: [{
            scope: "doctag",
            match: "@[A-Za-z]+"
          }] }), {
            match: /__halt_compiler\(\);/,
            keywords: "__halt_compiler",
            starts: {
              scope: "comment",
              end: e2.MATCH_NOTHING_RE,
              contains: [{ match: /\?>/, scope: "meta", endsParent: true }]
            }
          }, { scope: "meta", variants: [{
            begin: /<\?php/,
            relevance: 10
          }, { begin: /<\?=/ }, { begin: /<\?/, relevance: 0.1 }, {
            begin: /\?>/
          }] }, { scope: "variable.language", match: /\$this\b/ }, r2, w2, f2, {
            match: [/const/, /\s/, a2],
            scope: { 1: "keyword", 3: "variable.constant" }
          }, _2, {
            scope: "function",
            relevance: 0,
            beginKeywords: "fn function",
            end: /[;{]/,
            excludeEnd: true,
            illegal: "[$%\\[]",
            contains: [{
              beginKeywords: "use"
            }, e2.UNDERSCORE_TITLE_MODE, { begin: "=>", endsParent: true }, {
              scope: "params",
              begin: "\\(",
              end: "\\)",
              excludeBegin: true,
              excludeEnd: true,
              keywords: m2,
              contains: ["self", r2, f2, e2.C_BLOCK_COMMENT_MODE, c2, d2]
            }]
          }, { scope: "class", variants: [{
            beginKeywords: "enum",
            illegal: /[($"]/
          }, {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }], relevance: 0, end: /\{/, excludeEnd: true, contains: [{
            beginKeywords: "extends implements"
          }, e2.UNDERSCORE_TITLE_MODE] }, {
            beginKeywords: "namespace",
            relevance: 0,
            end: ";",
            illegal: /[.']/,
            contains: [e2.inherit(e2.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
          }, {
            beginKeywords: "use",
            relevance: 0,
            end: ";",
            contains: [{
              match: /\b(as|const|function)\b/,
              scope: "keyword"
            }, e2.UNDERSCORE_TITLE_MODE]
          }, c2, d2]
        };
      },
      grmr_php_template: (e2) => ({ name: "PHP template", subLanguage: "xml", contains: [{
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [{
          begin: "/\\*",
          end: "\\*/",
          skip: true
        }, { begin: 'b"', end: '"', skip: true }, {
          begin: "b'",
          end: "'",
          skip: true
        }, e2.inherit(e2.APOS_STRING_MODE, {
          illegal: null,
          className: null,
          contains: null,
          skip: true
        }), e2.inherit(e2.QUOTE_STRING_MODE, {
          illegal: null,
          className: null,
          contains: null,
          skip: true
        })]
      }] }),
      grmr_plaintext: (e2) => ({
        name: "Plain text",
        aliases: ["text", "txt"],
        disableAutodetect: true
      }),
      grmr_python: (e2) => {
        const n2 = e2.regex, t2 = /[\p{XID_Start}_]\p{XID_Continue}*/u, a2 = ["and", "as", "assert", "async", "await", "break", "case", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "match", "nonlocal|10", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"], i2 = {
          $pattern: /[A-Za-z]\w+|__\w+__/,
          keyword: a2,
          built_in: ["__import__", "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "filter", "float", "format", "frozenset", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", "ord", "pow", "print", "property", "range", "repr", "reversed", "round", "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"],
          literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"],
          type: ["Any", "Callable", "Coroutine", "Dict", "List", "Literal", "Generic", "Optional", "Sequence", "Set", "Tuple", "Type", "Union"]
        }, r2 = { className: "meta", begin: /^(>>>|\.\.\.) / }, s2 = {
          className: "subst",
          begin: /\{/,
          end: /\}/,
          keywords: i2,
          illegal: /#/
        }, o2 = { begin: /\{\{/, relevance: 0 }, l2 = {
          className: "string",
          contains: [e2.BACKSLASH_ESCAPE],
          variants: [{
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
            end: /'''/,
            contains: [e2.BACKSLASH_ESCAPE, r2],
            relevance: 10
          }, {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
            end: /"""/,
            contains: [e2.BACKSLASH_ESCAPE, r2],
            relevance: 10
          }, {
            begin: /([fF][rR]|[rR][fF]|[fF])'''/,
            end: /'''/,
            contains: [e2.BACKSLASH_ESCAPE, r2, o2, s2]
          }, {
            begin: /([fF][rR]|[rR][fF]|[fF])"""/,
            end: /"""/,
            contains: [e2.BACKSLASH_ESCAPE, r2, o2, s2]
          }, {
            begin: /([uU]|[rR])'/,
            end: /'/,
            relevance: 10
          }, { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 }, {
            begin: /([bB]|[bB][rR]|[rR][bB])'/,
            end: /'/
          }, {
            begin: /([bB]|[bB][rR]|[rR][bB])"/,
            end: /"/
          }, {
            begin: /([fF][rR]|[rR][fF]|[fF])'/,
            end: /'/,
            contains: [e2.BACKSLASH_ESCAPE, o2, s2]
          }, {
            begin: /([fF][rR]|[rR][fF]|[fF])"/,
            end: /"/,
            contains: [e2.BACKSLASH_ESCAPE, o2, s2]
          }, e2.APOS_STRING_MODE, e2.QUOTE_STRING_MODE]
        }, c2 = "[0-9](_?[0-9])*", d2 = `(\\b(${c2}))?\\.(${c2})|\\b(${c2})\\.`, g2 = "\\b|" + a2.join("|"), u2 = {
          className: "number",
          relevance: 0,
          variants: [{
            begin: `(\\b(${c2})|(${d2}))[eE][+-]?(${c2})[jJ]?(?=${g2})`
          }, { begin: `(${d2})[jJ]?` }, {
            begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${g2})`
          }, {
            begin: `\\b0[bB](_?[01])+[lL]?(?=${g2})`
          }, {
            begin: `\\b0[oO](_?[0-7])+[lL]?(?=${g2})`
          }, { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${g2})` }, {
            begin: `\\b(${c2})[jJ](?=${g2})`
          }]
        }, b2 = {
          className: "comment",
          begin: n2.lookahead(/# type:/),
          end: /$/,
          keywords: i2,
          contains: [{ begin: /# type:/ }, { begin: /#/, end: /\b\B/, endsWithParent: true }]
        }, m2 = {
          className: "params",
          variants: [{ className: "", begin: /\(\s*\)/, skip: true }, {
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: i2,
            contains: ["self", r2, u2, l2, e2.HASH_COMMENT_MODE]
          }]
        };
        return s2.contains = [l2, u2, r2], {
          name: "Python",
          aliases: ["py", "gyp", "ipython"],
          unicodeRegex: true,
          keywords: i2,
          illegal: /(<\/|->|\?)|=>/,
          contains: [r2, u2, { begin: /\bself\b/ }, {
            beginKeywords: "if",
            relevance: 0
          }, l2, b2, e2.HASH_COMMENT_MODE, { match: [/\bdef/, /\s+/, t2], scope: {
            1: "keyword",
            3: "title.function"
          }, contains: [m2] }, {
            variants: [{
              match: [/\bclass/, /\s+/, t2, /\s*/, /\(\s*/, t2, /\s*\)/]
            }, { match: [/\bclass/, /\s+/, t2] }],
            scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" }
          }, {
            className: "meta",
            begin: /^[\t ]*@/,
            end: /(?=#)|$/,
            contains: [u2, m2, l2]
          }]
        };
      },
      grmr_python_repl: (e2) => ({ aliases: ["pycon"], contains: [{
        className: "meta.prompt",
        starts: { end: / |$/, starts: { end: "$", subLanguage: "python" } },
        variants: [{
          begin: /^>>>(?=[ ]|$)/
        }, { begin: /^\.\.\.(?=[ ]|$)/ }]
      }] }),
      grmr_r: (e2) => {
        const n2 = e2.regex, t2 = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, a2 = n2.either(/0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/, /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/, /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/), i2 = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, r2 = n2.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
        return { name: "R", keywords: {
          $pattern: t2,
          keyword: "function if in break next repeat else for while",
          literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
          built_in: "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
        }, contains: [e2.COMMENT(/#'/, /$/, {
          contains: [{
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: n2.lookahead(n2.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)),
              endsParent: true
            }
          }, { scope: "doctag", begin: "@param", end: /$/, contains: [{
            scope: "variable",
            variants: [{ match: t2 }, { match: /`(?:\\.|[^`\\])+`/ }],
            endsParent: true
          }] }, { scope: "doctag", match: /@[a-zA-Z]+/ }, { scope: "keyword", match: /\\[a-zA-Z]+/ }]
        }), e2.HASH_COMMENT_MODE, {
          scope: "string",
          contains: [e2.BACKSLASH_ESCAPE],
          variants: [e2.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }), e2.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }), e2.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }), e2.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }), e2.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }), e2.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }), {
            begin: '"',
            end: '"',
            relevance: 0
          }, { begin: "'", end: "'", relevance: 0 }]
        }, { relevance: 0, variants: [{ scope: {
          1: "operator",
          2: "number"
        }, match: [i2, a2] }, {
          scope: { 1: "operator", 2: "number" },
          match: [/%[^%]*%/, a2]
        }, { scope: { 1: "punctuation", 2: "number" }, match: [r2, a2] }, { scope: {
          2: "number"
        }, match: [/[^a-zA-Z0-9._]|^/, a2] }] }, {
          scope: { 3: "operator" },
          match: [t2, /\s+/, /<-/, /\s+/]
        }, { scope: "operator", relevance: 0, variants: [{ match: i2 }, {
          match: /%[^%]*%/
        }] }, { scope: "punctuation", relevance: 0, match: r2 }, {
          begin: "`",
          end: "`",
          contains: [{ begin: /\\./ }]
        }] };
      },
      grmr_ruby: (e2) => {
        const n2 = e2.regex, t2 = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", a2 = n2.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/), i2 = n2.concat(a2, /(::\w+)*/), r2 = {
          "variable.constant": ["__FILE__", "__LINE__", "__ENCODING__"],
          "variable.language": ["self", "super"],
          keyword: ["alias", "and", "begin", "BEGIN", "break", "case", "class", "defined", "do", "else", "elsif", "end", "END", "ensure", "for", "if", "in", "module", "next", "not", "or", "redo", "require", "rescue", "retry", "return", "then", "undef", "unless", "until", "when", "while", "yield", "include", "extend", "prepend", "public", "private", "protected", "raise", "throw"],
          built_in: ["proc", "lambda", "attr_accessor", "attr_reader", "attr_writer", "define_method", "private_constant", "module_function"],
          literal: ["true", "false", "nil"]
        }, s2 = { className: "doctag", begin: "@[A-Za-z]+" }, o2 = {
          begin: "#<",
          end: ">"
        }, l2 = [e2.COMMENT("#", "$", {
          contains: [s2]
        }), e2.COMMENT("^=begin", "^=end", {
          contains: [s2],
          relevance: 10
        }), e2.COMMENT("^__END__", e2.MATCH_NOTHING_RE)], c2 = {
          className: "subst",
          begin: /#\{/,
          end: /\}/,
          keywords: r2
        }, d2 = {
          className: "string",
          contains: [e2.BACKSLASH_ESCAPE, c2],
          variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /`/, end: /`/ }, {
            begin: /%[qQwWx]?\(/,
            end: /\)/
          }, { begin: /%[qQwWx]?\[/, end: /\]/ }, {
            begin: /%[qQwWx]?\{/,
            end: /\}/
          }, { begin: /%[qQwWx]?</, end: />/ }, {
            begin: /%[qQwWx]?\//,
            end: /\//
          }, { begin: /%[qQwWx]?%/, end: /%/ }, { begin: /%[qQwWx]?-/, end: /-/ }, {
            begin: /%[qQwWx]?\|/,
            end: /\|/
          }, { begin: /\B\?(\\\d{1,3})/ }, {
            begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/
          }, { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ }, {
            begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/
          }, {
            begin: /\B\?\\(c|C-)[\x20-\x7e]/
          }, { begin: /\B\?\\?\S/ }, {
            begin: n2.concat(/<<[-~]?'?/, n2.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
            contains: [e2.END_SAME_AS_BEGIN({
              begin: /(\w+)/,
              end: /(\w+)/,
              contains: [e2.BACKSLASH_ESCAPE, c2]
            })]
          }]
        }, g2 = "[0-9](_?[0-9])*", u2 = {
          className: "number",
          relevance: 0,
          variants: [{
            begin: `\\b([1-9](_?[0-9])*|0)(\\.(${g2}))?([eE][+-]?(${g2})|r)?i?\\b`
          }, {
            begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b"
          }, {
            begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b"
          }, { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" }, {
            begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b"
          }, {
            begin: "\\b0(_?[0-7])+r?i?\\b"
          }]
        }, b2 = { variants: [{ match: /\(\)/ }, {
          className: "params",
          begin: /\(/,
          end: /(?=\))/,
          excludeBegin: true,
          endsParent: true,
          keywords: r2
        }] }, m2 = [d2, { variants: [{ match: [/class\s+/, i2, /\s+<\s+/, i2] }, {
          match: [/\b(class|module)\s+/, i2]
        }], scope: {
          2: "title.class",
          4: "title.class.inherited"
        }, keywords: r2 }, { match: [/(include|extend)\s+/, i2], scope: {
          2: "title.class"
        }, keywords: r2 }, { relevance: 0, match: [i2, /\.new[. (]/], scope: {
          1: "title.class"
        } }, {
          relevance: 0,
          match: /\b[A-Z][A-Z_0-9]+\b/,
          className: "variable.constant"
        }, { relevance: 0, match: a2, scope: "title.class" }, {
          match: [/def/, /\s+/, t2],
          scope: { 1: "keyword", 3: "title.function" },
          contains: [b2]
        }, {
          begin: e2.IDENT_RE + "::"
        }, {
          className: "symbol",
          begin: e2.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
          relevance: 0
        }, {
          className: "symbol",
          begin: ":(?!\\s)",
          contains: [d2, { begin: t2 }],
          relevance: 0
        }, u2, {
          className: "variable",
          begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
        }, {
          className: "params",
          begin: /\|/,
          end: /\|/,
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0,
          keywords: r2
        }, {
          begin: "(" + e2.RE_STARTERS_RE + "|unless)\\s*",
          keywords: "unless",
          contains: [{
            className: "regexp",
            contains: [e2.BACKSLASH_ESCAPE, c2],
            illegal: /\n/,
            variants: [{ begin: "/", end: "/[a-z]*" }, { begin: /%r\{/, end: /\}[a-z]*/ }, {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            }, { begin: "%r!", end: "![a-z]*" }, {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }]
          }].concat(o2, l2),
          relevance: 0
        }].concat(o2, l2);
        c2.contains = m2, b2.contains = m2;
        const p2 = [{
          begin: /^\s*=>/,
          starts: { end: "$", contains: m2 }
        }, {
          className: "meta.prompt",
          begin: "^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])",
          starts: { end: "$", keywords: r2, contains: m2 }
        }];
        return l2.unshift(o2), {
          name: "Ruby",
          aliases: ["rb", "gemspec", "podspec", "thor", "irb"],
          keywords: r2,
          illegal: /\/\*/,
          contains: [e2.SHEBANG({ binary: "ruby" })].concat(p2).concat(l2).concat(m2)
        };
      },
      grmr_rust: (e2) => {
        const n2 = e2.regex, t2 = {
          className: "title.function.invoke",
          relevance: 0,
          begin: n2.concat(/\b/, /(?!let\b)/, e2.IDENT_RE, n2.lookahead(/\s*\(/))
        }, a2 = "([ui](8|16|32|64|128|size)|f(32|64))?", i2 = ["drop ", "Copy", "Send", "Sized", "Sync", "Drop", "Fn", "FnMut", "FnOnce", "ToOwned", "Clone", "Debug", "PartialEq", "PartialOrd", "Eq", "Ord", "AsRef", "AsMut", "Into", "From", "Default", "Iterator", "Extend", "IntoIterator", "DoubleEndedIterator", "ExactSizeIterator", "SliceConcatExt", "ToString", "assert!", "assert_eq!", "bitflags!", "bytes!", "cfg!", "col!", "concat!", "concat_idents!", "debug_assert!", "debug_assert_eq!", "env!", "panic!", "file!", "format!", "format_args!", "include_bytes!", "include_str!", "line!", "local_data_key!", "module_path!", "option_env!", "print!", "println!", "select!", "stringify!", "try!", "unimplemented!", "unreachable!", "vec!", "write!", "writeln!", "macro_rules!", "assert_ne!", "debug_assert_ne!"], r2 = ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64", "u128", "usize", "f32", "f64", "str", "char", "bool", "Box", "Option", "Result", "String", "Vec"];
        return {
          name: "Rust",
          aliases: ["rs"],
          keywords: {
            $pattern: e2.IDENT_RE + "!?",
            type: r2,
            keyword: ["abstract", "as", "async", "await", "become", "box", "break", "const", "continue", "crate", "do", "dyn", "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop", "macro", "match", "mod", "move", "mut", "override", "priv", "pub", "ref", "return", "self", "Self", "static", "struct", "super", "trait", "true", "try", "type", "typeof", "unsafe", "unsized", "use", "virtual", "where", "while", "yield"],
            literal: ["true", "false", "Some", "None", "Ok", "Err"],
            built_in: i2
          },
          illegal: "</",
          contains: [e2.C_LINE_COMMENT_MODE, e2.COMMENT("/\\*", "\\*/", {
            contains: ["self"]
          }), e2.inherit(e2.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }), {
            className: "string",
            variants: [{ begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ }, {
              begin: /b?'\\?(x\w{2}|u\w{4}|U\w{8}|.)'/
            }]
          }, {
            className: "symbol",
            begin: /'[a-zA-Z_][a-zA-Z0-9_]*/
          }, { className: "number", variants: [{
            begin: "\\b0b([01_]+)" + a2
          }, { begin: "\\b0o([0-7_]+)" + a2 }, {
            begin: "\\b0x([A-Fa-f0-9_]+)" + a2
          }, {
            begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + a2
          }], relevance: 0 }, {
            begin: [/fn/, /\s+/, e2.UNDERSCORE_IDENT_RE],
            className: {
              1: "keyword",
              3: "title.function"
            }
          }, { className: "meta", begin: "#!?\\[", end: "\\]", contains: [{
            className: "string",
            begin: /"/,
            end: /"/
          }] }, {
            begin: [/let/, /\s+/, /(?:mut\s+)?/, e2.UNDERSCORE_IDENT_RE],
            className: {
              1: "keyword",
              3: "keyword",
              4: "variable"
            }
          }, {
            begin: [/for/, /\s+/, e2.UNDERSCORE_IDENT_RE, /\s+/, /in/],
            className: {
              1: "keyword",
              3: "variable",
              5: "keyword"
            }
          }, {
            begin: [/type/, /\s+/, e2.UNDERSCORE_IDENT_RE],
            className: { 1: "keyword", 3: "title.class" }
          }, {
            begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, e2.UNDERSCORE_IDENT_RE],
            className: { 1: "keyword", 3: "title.class" }
          }, { begin: e2.IDENT_RE + "::", keywords: {
            keyword: "Self",
            built_in: i2,
            type: r2
          } }, { className: "punctuation", begin: "->" }, t2]
        };
      },
      grmr_scss: (e2) => {
        const n2 = te(e2), t2 = se, a2 = re, i2 = "@[a-z-]+", r2 = {
          className: "variable",
          begin: "(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b",
          relevance: 0
        };
        return {
          name: "SCSS",
          case_insensitive: true,
          illegal: "[=/|']",
          contains: [e2.C_LINE_COMMENT_MODE, e2.C_BLOCK_COMMENT_MODE, n2.CSS_NUMBER_MODE, {
            className: "selector-id",
            begin: "#[A-Za-z0-9_-]+",
            relevance: 0
          }, {
            className: "selector-class",
            begin: "\\.[A-Za-z0-9_-]+",
            relevance: 0
          }, n2.ATTRIBUTE_SELECTOR_MODE, {
            className: "selector-tag",
            begin: "\\b(" + ae.join("|") + ")\\b",
            relevance: 0
          }, {
            className: "selector-pseudo",
            begin: ":(" + a2.join("|") + ")"
          }, {
            className: "selector-pseudo",
            begin: ":(:)?(" + t2.join("|") + ")"
          }, r2, {
            begin: /\(/,
            end: /\)/,
            contains: [n2.CSS_NUMBER_MODE]
          }, n2.CSS_VARIABLE, {
            className: "attribute",
            begin: "\\b(" + oe.join("|") + ")\\b"
          }, {
            begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"
          }, {
            begin: /:/,
            end: /[;}{]/,
            relevance: 0,
            contains: [n2.BLOCK_COMMENT, r2, n2.HEXCOLOR, n2.CSS_NUMBER_MODE, e2.QUOTE_STRING_MODE, e2.APOS_STRING_MODE, n2.IMPORTANT, n2.FUNCTION_DISPATCH]
          }, { begin: "@(page|font-face)", keywords: { $pattern: i2, keyword: "@page @font-face" } }, {
            begin: "@",
            end: "[{;]",
            returnBegin: true,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: "and or not only",
              attribute: ie.join(" ")
            },
            contains: [{
              begin: i2,
              className: "keyword"
            }, {
              begin: /[a-z-]+(?=:)/,
              className: "attribute"
            }, r2, e2.QUOTE_STRING_MODE, e2.APOS_STRING_MODE, n2.HEXCOLOR, n2.CSS_NUMBER_MODE]
          }, n2.FUNCTION_DISPATCH]
        };
      },
      grmr_shell: (e2) => ({
        name: "Shell Session",
        aliases: ["console", "shellsession"],
        contains: [{
          className: "meta.prompt",
          begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
          starts: {
            end: /[^\\](?=\s*$)/,
            subLanguage: "bash"
          }
        }]
      }),
      grmr_sql: (e2) => {
        const n2 = e2.regex, t2 = e2.COMMENT("--", "$"), a2 = ["true", "false", "unknown"], i2 = ["bigint", "binary", "blob", "boolean", "char", "character", "clob", "date", "dec", "decfloat", "decimal", "float", "int", "integer", "interval", "nchar", "nclob", "national", "numeric", "real", "row", "smallint", "time", "timestamp", "varchar", "varying", "varbinary"], r2 = ["abs", "acos", "array_agg", "asin", "atan", "avg", "cast", "ceil", "ceiling", "coalesce", "corr", "cos", "cosh", "count", "covar_pop", "covar_samp", "cume_dist", "dense_rank", "deref", "element", "exp", "extract", "first_value", "floor", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "last_value", "lead", "listagg", "ln", "log", "log10", "lower", "max", "min", "mod", "nth_value", "ntile", "nullif", "percent_rank", "percentile_cont", "percentile_disc", "position", "position_regex", "power", "rank", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "row_number", "sin", "sinh", "sqrt", "stddev_pop", "stddev_samp", "substring", "substring_regex", "sum", "tan", "tanh", "translate", "translate_regex", "treat", "trim", "trim_array", "unnest", "upper", "value_of", "var_pop", "var_samp", "width_bucket"], s2 = ["create table", "insert into", "primary key", "foreign key", "not null", "alter table", "add constraint", "grouping sets", "on overflow", "character set", "respect nulls", "ignore nulls", "nulls first", "nulls last", "depth first", "breadth first"], o2 = r2, l2 = ["abs", "acos", "all", "allocate", "alter", "and", "any", "are", "array", "array_agg", "array_max_cardinality", "as", "asensitive", "asin", "asymmetric", "at", "atan", "atomic", "authorization", "avg", "begin", "begin_frame", "begin_partition", "between", "bigint", "binary", "blob", "boolean", "both", "by", "call", "called", "cardinality", "cascaded", "case", "cast", "ceil", "ceiling", "char", "char_length", "character", "character_length", "check", "classifier", "clob", "close", "coalesce", "collate", "collect", "column", "commit", "condition", "connect", "constraint", "contains", "convert", "copy", "corr", "corresponding", "cos", "cosh", "count", "covar_pop", "covar_samp", "create", "cross", "cube", "cume_dist", "current", "current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_row", "current_schema", "current_time", "current_timestamp", "current_path", "current_role", "current_transform_group_for_type", "current_user", "cursor", "cycle", "date", "day", "deallocate", "dec", "decimal", "decfloat", "declare", "default", "define", "delete", "dense_rank", "deref", "describe", "deterministic", "disconnect", "distinct", "double", "drop", "dynamic", "each", "element", "else", "empty", "end", "end_frame", "end_partition", "end-exec", "equals", "escape", "every", "except", "exec", "execute", "exists", "exp", "external", "extract", "false", "fetch", "filter", "first_value", "float", "floor", "for", "foreign", "frame_row", "free", "from", "full", "function", "fusion", "get", "global", "grant", "group", "grouping", "groups", "having", "hold", "hour", "identity", "in", "indicator", "initial", "inner", "inout", "insensitive", "insert", "int", "integer", "intersect", "intersection", "interval", "into", "is", "join", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "language", "large", "last_value", "lateral", "lead", "leading", "left", "like", "like_regex", "listagg", "ln", "local", "localtime", "localtimestamp", "log", "log10", "lower", "match", "match_number", "match_recognize", "matches", "max", "member", "merge", "method", "min", "minute", "mod", "modifies", "module", "month", "multiset", "national", "natural", "nchar", "nclob", "new", "no", "none", "normalize", "not", "nth_value", "ntile", "null", "nullif", "numeric", "octet_length", "occurrences_regex", "of", "offset", "old", "omit", "on", "one", "only", "open", "or", "order", "out", "outer", "over", "overlaps", "overlay", "parameter", "partition", "pattern", "per", "percent", "percent_rank", "percentile_cont", "percentile_disc", "period", "portion", "position", "position_regex", "power", "precedes", "precision", "prepare", "primary", "procedure", "ptf", "range", "rank", "reads", "real", "recursive", "ref", "references", "referencing", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "release", "result", "return", "returns", "revoke", "right", "rollback", "rollup", "row", "row_number", "rows", "running", "savepoint", "scope", "scroll", "search", "second", "seek", "select", "sensitive", "session_user", "set", "show", "similar", "sin", "sinh", "skip", "smallint", "some", "specific", "specifictype", "sql", "sqlexception", "sqlstate", "sqlwarning", "sqrt", "start", "static", "stddev_pop", "stddev_samp", "submultiset", "subset", "substring", "substring_regex", "succeeds", "sum", "symmetric", "system", "system_time", "system_user", "table", "tablesample", "tan", "tanh", "then", "time", "timestamp", "timezone_hour", "timezone_minute", "to", "trailing", "translate", "translate_regex", "translation", "treat", "trigger", "trim", "trim_array", "true", "truncate", "uescape", "union", "unique", "unknown", "unnest", "update", "upper", "user", "using", "value", "values", "value_of", "var_pop", "var_samp", "varbinary", "varchar", "varying", "versioning", "when", "whenever", "where", "width_bucket", "window", "with", "within", "without", "year", "add", "asc", "collation", "desc", "final", "first", "last", "view"].filter((e3) => !r2.includes(e3)), c2 = {
          begin: n2.concat(/\b/, n2.either(...o2), /\s*\(/),
          relevance: 0,
          keywords: { built_in: o2 }
        };
        return { name: "SQL", case_insensitive: true, illegal: /[{}]|<\//, keywords: {
          $pattern: /\b[\w\.]+/,
          keyword: ((e3, { exceptions: n3, when: t3 } = {}) => {
            const a3 = t3;
            return n3 = n3 || [], e3.map((e4) => e4.match(/\|\d+$/) || n3.includes(e4) ? e4 : a3(e4) ? e4 + "|0" : e4);
          })(l2, { when: (e3) => e3.length < 3 }),
          literal: a2,
          type: i2,
          built_in: ["current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_schema", "current_transform_group_for_type", "current_user", "session_user", "system_time", "system_user", "current_time", "localtime", "current_timestamp", "localtimestamp"]
        }, contains: [{ begin: n2.either(...s2), relevance: 0, keywords: {
          $pattern: /[\w\.]+/,
          keyword: l2.concat(s2),
          literal: a2,
          type: i2
        } }, {
          className: "type",
          begin: n2.either("double precision", "large object", "with timezone", "without timezone")
        }, c2, { className: "variable", begin: /@[a-z0-9]+/ }, { className: "string", variants: [{
          begin: /'/,
          end: /'/,
          contains: [{ begin: /''/ }]
        }] }, { begin: /"/, end: /"/, contains: [{
          begin: /""/
        }] }, e2.C_NUMBER_MODE, e2.C_BLOCK_COMMENT_MODE, t2, {
          className: "operator",
          begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
          relevance: 0
        }] };
      },
      grmr_swift: (e2) => {
        const n2 = { match: /\s+/, relevance: 0 }, t2 = e2.COMMENT("/\\*", "\\*/", {
          contains: ["self"]
        }), a2 = [e2.C_LINE_COMMENT_MODE, t2], i2 = {
          match: [/\./, p(...ve, ...Oe)],
          className: { 2: "keyword" }
        }, r2 = {
          match: m(/\./, p(...xe)),
          relevance: 0
        }, s2 = xe.filter((e3) => typeof e3 == "string").concat(["_|0"]), o2 = { variants: [{
          className: "keyword",
          match: p(...xe.filter((e3) => typeof e3 != "string").concat(ke).map(Ne), ...Oe)
        }] }, l2 = {
          $pattern: p(/\b\w+/, /#\w+/),
          keyword: s2.concat(Ae),
          literal: Me
        }, c2 = [i2, r2, o2], d2 = [{
          match: m(/\./, p(...Ce)),
          relevance: 0
        }, {
          className: "built_in",
          match: m(/\b/, p(...Ce), /(?=\()/)
        }], u2 = { match: /->/, relevance: 0 }, b2 = [u2, {
          className: "operator",
          relevance: 0,
          variants: [{ match: De }, { match: `\\.(\\.|${Re})+` }]
        }], _2 = "([0-9a-fA-F]_*)+", h2 = { className: "number", relevance: 0, variants: [{
          match: "\\b(([0-9]_*)+)(\\.(([0-9]_*)+))?([eE][+-]?(([0-9]_*)+))?\\b"
        }, {
          match: `\\b0x(${_2})(\\.(${_2}))?([pP][+-]?(([0-9]_*)+))?\\b`
        }, {
          match: /\b0o([0-7]_*)+\b/
        }, { match: /\b0b([01]_*)+\b/ }] }, f2 = (e3 = "") => ({
          className: "subst",
          variants: [{ match: m(/\\/, e3, /[0\\tnr"']/) }, {
            match: m(/\\/, e3, /u\{[0-9a-fA-F]{1,8}\}/)
          }]
        }), E2 = (e3 = "") => ({
          className: "subst",
          match: m(/\\/, e3, /[\t ]*(?:[\r\n]|\r\n)/)
        }), y2 = (e3 = "") => ({
          className: "subst",
          label: "interpol",
          begin: m(/\\/, e3, /\(/),
          end: /\)/
        }), w2 = (e3 = "") => ({
          begin: m(e3, /"""/),
          end: m(/"""/, e3),
          contains: [f2(e3), E2(e3), y2(e3)]
        }), N2 = (e3 = "") => ({
          begin: m(e3, /"/),
          end: m(/"/, e3),
          contains: [f2(e3), y2(e3)]
        }), v2 = {
          className: "string",
          variants: [w2(), w2("#"), w2("##"), w2("###"), N2(), N2("#"), N2("##"), N2("###")]
        }, O2 = {
          match: m(/`/, Be, /`/)
        }, k2 = [O2, { className: "variable", match: /\$\d+/ }, {
          className: "variable",
          match: `\\\$${Le}+`
        }], x2 = [{
          match: /(@|#(un)?)available/,
          className: "keyword",
          starts: { contains: [{
            begin: /\(/,
            end: /\)/,
            keywords: Fe,
            contains: [...b2, h2, v2]
          }] }
        }, { className: "keyword", match: m(/@/, p(...ze)) }, {
          className: "meta",
          match: m(/@/, Be)
        }], M2 = { match: g(/\b[A-Z]/), relevance: 0, contains: [{
          className: "type",
          match: m(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Le, "+")
        }, { className: "type", match: $e, relevance: 0 }, { match: /[?!]+/, relevance: 0 }, {
          match: /\.\.\./,
          relevance: 0
        }, { match: m(/\s+&\s+/, g($e)), relevance: 0 }] }, S2 = {
          begin: /</,
          end: />/,
          keywords: l2,
          contains: [...a2, ...c2, ...x2, u2, M2]
        };
        M2.contains.push(S2);
        const A2 = { begin: /\(/, end: /\)/, relevance: 0, keywords: l2, contains: ["self", {
          match: m(Be, /\s*:/),
          keywords: "_|0",
          relevance: 0
        }, ...a2, ...c2, ...d2, ...b2, h2, v2, ...k2, ...x2, M2] }, C2 = {
          begin: /</,
          end: />/,
          contains: [...a2, M2]
        }, T2 = { begin: /\(/, end: /\)/, keywords: l2, contains: [{
          begin: p(g(m(Be, /\s*:/)), g(m(Be, /\s+/, Be, /\s*:/))),
          end: /:/,
          relevance: 0,
          contains: [{ className: "keyword", match: /\b_\b/ }, { className: "params", match: Be }]
        }, ...a2, ...c2, ...b2, h2, v2, ...x2, M2, A2], endsParent: true, illegal: /["']/ }, R2 = {
          match: [/func/, /\s+/, p(O2.match, Be, De)],
          className: {
            1: "keyword",
            3: "title.function"
          },
          contains: [C2, T2, n2],
          illegal: [/\[/, /%/]
        }, D2 = {
          match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
          className: { 1: "keyword" },
          contains: [C2, T2, n2],
          illegal: /\[|%/
        }, I2 = { match: [/operator/, /\s+/, De], className: {
          1: "keyword",
          3: "title"
        } }, L2 = { begin: [/precedencegroup/, /\s+/, $e], className: {
          1: "keyword",
          3: "title"
        }, contains: [M2], keywords: [...Se, ...Me], end: /}/ };
        for (const e3 of v2.variants) {
          const n3 = e3.contains.find((e4) => e4.label === "interpol");
          n3.keywords = l2;
          const t3 = [...c2, ...d2, ...b2, h2, v2, ...k2];
          n3.contains = [...t3, {
            begin: /\(/,
            end: /\)/,
            contains: ["self", ...t3]
          }];
        }
        return {
          name: "Swift",
          keywords: l2,
          contains: [...a2, R2, D2, {
            beginKeywords: "struct protocol class extension enum actor",
            end: "\\{",
            excludeEnd: true,
            keywords: l2,
            contains: [e2.inherit(e2.TITLE_MODE, {
              className: "title.class",
              begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
            }), ...c2]
          }, I2, L2, {
            beginKeywords: "import",
            end: /$/,
            contains: [...a2],
            relevance: 0
          }, ...c2, ...d2, ...b2, h2, v2, ...k2, ...x2, M2, A2]
        };
      },
      grmr_typescript: (e2) => {
        const n2 = we(e2), t2 = ["any", "void", "number", "boolean", "string", "object", "never", "symbol", "bigint", "unknown"], a2 = {
          beginKeywords: "namespace",
          end: /\{/,
          excludeEnd: true,
          contains: [n2.exports.CLASS_REFERENCE]
        }, i2 = {
          beginKeywords: "interface",
          end: /\{/,
          excludeEnd: true,
          keywords: { keyword: "interface extends", built_in: t2 },
          contains: [n2.exports.CLASS_REFERENCE]
        }, r2 = {
          $pattern: be,
          keyword: me.concat(["type", "namespace", "interface", "public", "private", "protected", "implements", "declare", "abstract", "readonly", "enum", "override"]),
          literal: pe,
          built_in: ye.concat(t2),
          "variable.language": Ee
        }, s2 = {
          className: "meta",
          begin: "@[A-Za-z$_][0-9A-Za-z$_]*"
        }, o2 = (e3, n3, t3) => {
          const a3 = e3.contains.findIndex((e4) => e4.label === n3);
          if (a3 === -1)
            throw Error("can not find mode to replace");
          e3.contains.splice(a3, 1, t3);
        };
        return Object.assign(n2.keywords, r2), n2.exports.PARAMS_CONTAINS.push(s2), n2.contains = n2.contains.concat([s2, a2, i2]), o2(n2, "shebang", e2.SHEBANG()), o2(n2, "use_strict", {
          className: "meta",
          relevance: 10,
          begin: /^\s*['"]use strict['"]/
        }), n2.contains.find((e3) => e3.label === "func.def").relevance = 0, Object.assign(n2, {
          name: "TypeScript",
          aliases: ["ts", "tsx"]
        }), n2;
      },
      grmr_vbnet: (e2) => {
        const n2 = e2.regex, t2 = /\d{1,2}\/\d{1,2}\/\d{4}/, a2 = /\d{4}-\d{1,2}-\d{1,2}/, i2 = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, r2 = /\d{1,2}(:\d{1,2}){1,2}/, s2 = {
          className: "literal",
          variants: [{ begin: n2.concat(/# */, n2.either(a2, t2), / *#/) }, {
            begin: n2.concat(/# */, r2, / *#/)
          }, { begin: n2.concat(/# */, i2, / *#/) }, {
            begin: n2.concat(/# */, n2.either(a2, t2), / +/, n2.either(i2, r2), / *#/)
          }]
        }, o2 = e2.COMMENT(/'''/, /$/, {
          contains: [{ className: "doctag", begin: /<\/?/, end: />/ }]
        }), l2 = e2.COMMENT(null, /$/, { variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }] });
        return {
          name: "Visual Basic .NET",
          aliases: ["vb"],
          case_insensitive: true,
          classNameAliases: { label: "symbol" },
          keywords: {
            keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
            built_in: "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort",
            type: "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort",
            literal: "true false nothing"
          },
          illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
          contains: [{
            className: "string",
            begin: /"(""|[^/n])"C\b/
          }, {
            className: "string",
            begin: /"/,
            end: /"/,
            illegal: /\n/,
            contains: [{ begin: /""/ }]
          }, s2, {
            className: "number",
            relevance: 0,
            variants: [{
              begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
            }, { begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ }, { begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ }, {
              begin: /&O[0-7_]+((U?[SIL])|[%&])?/
            }, { begin: /&B[01_]+((U?[SIL])|[%&])?/ }]
          }, {
            className: "label",
            begin: /^\w+:/
          }, o2, l2, {
            className: "meta",
            begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
            end: /$/,
            keywords: {
              keyword: "const disable else elseif enable end externalsource if region then"
            },
            contains: [l2]
          }]
        };
      },
      grmr_wasm: (e2) => {
        e2.regex;
        const n2 = e2.COMMENT(/\(;/, /;\)/);
        return n2.contains.push("self"), { name: "WebAssembly", keywords: {
          $pattern: /[\w.]+/,
          keyword: ["anyfunc", "block", "br", "br_if", "br_table", "call", "call_indirect", "data", "drop", "elem", "else", "end", "export", "func", "global.get", "global.set", "local.get", "local.set", "local.tee", "get_global", "get_local", "global", "if", "import", "local", "loop", "memory", "memory.grow", "memory.size", "module", "mut", "nop", "offset", "param", "result", "return", "select", "set_global", "set_local", "start", "table", "tee_local", "then", "type", "unreachable"]
        }, contains: [e2.COMMENT(/;;/, /$/), n2, {
          match: [/(?:offset|align)/, /\s*/, /=/],
          className: { 1: "keyword", 3: "operator" }
        }, { className: "variable", begin: /\$[\w_]+/ }, {
          match: /(\((?!;)|\))+/,
          className: "punctuation",
          relevance: 0
        }, {
          begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/],
          className: {
            1: "keyword",
            3: "title.function"
          }
        }, e2.QUOTE_STRING_MODE, {
          match: /(i32|i64|f32|f64)(?!\.)/,
          className: "type"
        }, {
          className: "keyword",
          match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
        }, {
          className: "number",
          relevance: 0,
          match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
        }] };
      },
      grmr_yaml: (e2) => {
        const n2 = "true false yes no null", t2 = "[\\w#;/?:@&=+$,.~*'()[\\]]+", a2 = {
          className: "string",
          relevance: 0,
          variants: [{ begin: /'/, end: /'/ }, {
            begin: /"/,
            end: /"/
          }, { begin: /\S+/ }],
          contains: [e2.BACKSLASH_ESCAPE, {
            className: "template-variable",
            variants: [{ begin: /\{\{/, end: /\}\}/ }, { begin: /%\{/, end: /\}/ }]
          }]
        }, i2 = e2.inherit(a2, {
          variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /[^\s,{}[\]]+/ }]
        }), r2 = {
          end: ",",
          endsWithParent: true,
          excludeEnd: true,
          keywords: n2,
          relevance: 0
        }, s2 = {
          begin: /\{/,
          end: /\}/,
          contains: [r2],
          illegal: "\\n",
          relevance: 0
        }, o2 = {
          begin: "\\[",
          end: "\\]",
          contains: [r2],
          illegal: "\\n",
          relevance: 0
        }, l2 = [{ className: "attr", variants: [{
          begin: "\\w[\\w :\\/.-]*:(?=[ \t]|$)"
        }, { begin: '"\\w[\\w :\\/.-]*":(?=[ \t]|$)' }, {
          begin: "'\\w[\\w :\\/.-]*':(?=[ \t]|$)"
        }] }, {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        }, {
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        }, {
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        }, { className: "type", begin: "!\\w+!" + t2 }, {
          className: "type",
          begin: "!<" + t2 + ">"
        }, { className: "type", begin: "!" + t2 }, {
          className: "type",
          begin: "!!" + t2
        }, { className: "meta", begin: "&" + e2.UNDERSCORE_IDENT_RE + "$" }, {
          className: "meta",
          begin: "\\*" + e2.UNDERSCORE_IDENT_RE + "$"
        }, {
          className: "bullet",
          begin: "-(?=[ ]|$)",
          relevance: 0
        }, e2.HASH_COMMENT_MODE, { beginKeywords: n2, keywords: { literal: n2 } }, {
          className: "number",
          begin: "\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b"
        }, { className: "number", begin: e2.C_NUMBER_RE + "\\b", relevance: 0 }, s2, o2, a2], c2 = [...l2];
        return c2.pop(), c2.push(i2), r2.contains = c2, {
          name: "YAML",
          case_insensitive: true,
          aliases: ["yml"],
          contains: l2
        };
      }
    });
    const je = ne;
    for (const e2 of Object.keys(Ue)) {
      const n2 = e2.replace("grmr_", "").replace("_", "-");
      je.registerLanguage(n2, Ue[e2]);
    }
    return je;
  }();
  typeof exports == "object" && typeof module != "undefined" && (module.exports = hljs);
});

// assets/scripts/purify.min.js
var require_purify_min = __commonJS((exports, module) => {
  /*! @license DOMPurify 3.0.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.0/LICENSE */
  (function(e, t) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).DOMPurify = t();
  })(exports, function() {
    function e(t2) {
      return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e2) {
        return typeof e2;
      } : function(e2) {
        return e2 && typeof Symbol == "function" && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
      }, e(t2);
    }
    function t(e2, n2) {
      return t = Object.setPrototypeOf || function(e3, t2) {
        return e3.__proto__ = t2, e3;
      }, t(e2, n2);
    }
    function n() {
      if (typeof Reflect == "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy == "function")
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (e2) {
        return false;
      }
    }
    function r(e2, o2, a2) {
      return r = n() ? Reflect.construct : function(e3, n2, r2) {
        var o3 = [null];
        o3.push.apply(o3, n2);
        var a3 = new (Function.bind.apply(e3, o3));
        return r2 && t(a3, r2.prototype), a3;
      }, r.apply(null, arguments);
    }
    function o(e2, t2) {
      return function(e3) {
        if (Array.isArray(e3))
          return e3;
      }(e2) || function(e3, t3) {
        var n2 = e3 == null ? null : typeof Symbol != "undefined" && e3[Symbol.iterator] || e3["@@iterator"];
        if (n2 == null)
          return;
        var r2, o2, a2 = [], i2 = true, l2 = false;
        try {
          for (n2 = n2.call(e3);!(i2 = (r2 = n2.next()).done) && (a2.push(r2.value), !t3 || a2.length !== t3); i2 = true)
            ;
        } catch (e4) {
          l2 = true, o2 = e4;
        } finally {
          try {
            i2 || n2.return == null || n2.return();
          } finally {
            if (l2)
              throw o2;
          }
        }
        return a2;
      }(e2, t2) || i(e2, t2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function a(e2) {
      return function(e3) {
        if (Array.isArray(e3))
          return l(e3);
      }(e2) || function(e3) {
        if (typeof Symbol != "undefined" && e3[Symbol.iterator] != null || e3["@@iterator"] != null)
          return Array.from(e3);
      }(e2) || i(e2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function i(e2, t2) {
      if (e2) {
        if (typeof e2 == "string")
          return l(e2, t2);
        var n2 = Object.prototype.toString.call(e2).slice(8, -1);
        return n2 === "Object" && e2.constructor && (n2 = e2.constructor.name), n2 === "Map" || n2 === "Set" ? Array.from(e2) : n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? l(e2, t2) : undefined;
      }
    }
    function l(e2, t2) {
      (t2 == null || t2 > e2.length) && (t2 = e2.length);
      for (var n2 = 0, r2 = new Array(t2);n2 < t2; n2++)
        r2[n2] = e2[n2];
      return r2;
    }
    var { entries: c, setPrototypeOf: u, isFrozen: s, getPrototypeOf: f, getOwnPropertyDescriptor: m, freeze: p, seal: d, create: h } = Object, y = typeof Reflect != "undefined" && Reflect, g = y.apply, b = y.construct;
    g || (g = function(e2, t2, n2) {
      return e2.apply(t2, n2);
    }), p || (p = function(e2) {
      return e2;
    }), d || (d = function(e2) {
      return e2;
    }), b || (b = function(e2, t2) {
      return r(e2, a(t2));
    });
    var v, T = R(Array.prototype.forEach), N = R(Array.prototype.pop), A = R(Array.prototype.push), E = R(String.prototype.toLowerCase), w = R(String.prototype.toString), S = R(String.prototype.match), _ = R(String.prototype.replace), x = R(String.prototype.indexOf), k = R(String.prototype.trim), O = R(RegExp.prototype.test), D = (v = TypeError, function() {
      for (var e2 = arguments.length, t2 = new Array(e2), n2 = 0;n2 < e2; n2++)
        t2[n2] = arguments[n2];
      return b(v, t2);
    });
    function R(e2) {
      return function(t2) {
        for (var n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), o2 = 1;o2 < n2; o2++)
          r2[o2 - 1] = arguments[o2];
        return g(e2, t2, r2);
      };
    }
    function C(e2, t2, n2) {
      n2 = n2 || E, u && u(e2, null);
      for (var r2 = t2.length;r2--; ) {
        var o2 = t2[r2];
        if (typeof o2 == "string") {
          var a2 = n2(o2);
          a2 !== o2 && (s(t2) || (t2[r2] = a2), o2 = a2);
        }
        e2[o2] = true;
      }
      return e2;
    }
    function L(e2) {
      var t2, n2 = h(null), r2 = function(e3, t3) {
        var n3 = typeof Symbol != "undefined" && e3[Symbol.iterator] || e3["@@iterator"];
        if (!n3) {
          if (Array.isArray(e3) || (n3 = i(e3)) || t3 && e3 && typeof e3.length == "number") {
            n3 && (e3 = n3);
            var r3 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return r3 >= e3.length ? { done: true } : { done: false, value: e3[r3++] };
            }, e: function(e4) {
              throw e4;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var a3, l3 = true, c2 = false;
        return { s: function() {
          n3 = n3.call(e3);
        }, n: function() {
          var e4 = n3.next();
          return l3 = e4.done, e4;
        }, e: function(e4) {
          c2 = true, a3 = e4;
        }, f: function() {
          try {
            l3 || n3.return == null || n3.return();
          } finally {
            if (c2)
              throw a3;
          }
        } };
      }(c(e2));
      try {
        for (r2.s();!(t2 = r2.n()).done; ) {
          var a2 = o(t2.value, 2), l2 = a2[0], u2 = a2[1];
          n2[l2] = u2;
        }
      } catch (e3) {
        r2.e(e3);
      } finally {
        r2.f();
      }
      return n2;
    }
    function M(e2, t2) {
      for (;e2 !== null; ) {
        var n2 = m(e2, t2);
        if (n2) {
          if (n2.get)
            return R(n2.get);
          if (typeof n2.value == "function")
            return R(n2.value);
        }
        e2 = f(e2);
      }
      return function(e3) {
        return console.warn("fallback value for", e3), null;
      };
    }
    var I = p(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), U = p(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), F = p(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), z = p(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), H = p(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), j = p(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), P = p(["#text"]), B = p(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), G = p(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), W = p(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), q = p(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Y = d(/\{\{[\w\W]*|[\w\W]*\}\}/gm), $ = d(/<%[\w\W]*|[\w\W]*%>/gm), K = d(/\${[\w\W]*}/gm), V = d(/^data-[\-\w.\u00B7-\uFFFF]/), X = d(/^aria-[\-\w]+$/), Z = d(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), J = d(/^(?:\w+script|data):/i), Q = d(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), ee = d(/^html$/i), te = function() {
      return typeof window == "undefined" ? null : window;
    }, ne = function(t2, n2) {
      if (e(t2) !== "object" || typeof t2.createPolicy != "function")
        return null;
      var r2 = null, o2 = "data-tt-policy-suffix";
      n2.currentScript && n2.currentScript.hasAttribute(o2) && (r2 = n2.currentScript.getAttribute(o2));
      var a2 = "dompurify" + (r2 ? "#" + r2 : "");
      try {
        return t2.createPolicy(a2, { createHTML: function(e2) {
          return e2;
        }, createScriptURL: function(e2) {
          return e2;
        } });
      } catch (e2) {
        return console.warn("TrustedTypes policy " + a2 + " could not be created."), null;
      }
    };
    var re = function t() {
      var n2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : te(), r2 = function(e2) {
        return t(e2);
      };
      if (r2.version = "3.0.0", r2.removed = [], !n2 || !n2.document || n2.document.nodeType !== 9)
        return r2.isSupported = false, r2;
      var { document: o2, document: i2, DocumentFragment: l2, HTMLTemplateElement: u2, Node: s2, Element: f2, NodeFilter: m2, NamedNodeMap: d2 } = n2, h2 = d2 === undefined ? n2.NamedNodeMap || n2.MozNamedAttrMap : d2, y2 = n2.HTMLFormElement, g2 = n2.DOMParser, b2 = n2.trustedTypes, v2 = f2.prototype, R2 = M(v2, "cloneNode"), re2 = M(v2, "nextSibling"), oe = M(v2, "childNodes"), ae = M(v2, "parentNode");
      if (typeof u2 == "function") {
        var ie = i2.createElement("template");
        ie.content && ie.content.ownerDocument && (i2 = ie.content.ownerDocument);
      }
      var le = ne(b2, o2), ce = le ? le.createHTML("") : "", ue = i2, se = ue.implementation, fe = ue.createNodeIterator, me = ue.createDocumentFragment, pe = ue.getElementsByTagName, de = o2.importNode, he = {};
      r2.isSupported = typeof c == "function" && typeof ae == "function" && se && se.createHTMLDocument !== undefined;
      var ye, ge, be = Y, ve = $, Te = K, Ne = V, Ae = X, Ee = J, we = Q, Se = Z, _e = null, xe = C({}, [].concat(a(I), a(U), a(F), a(H), a(P))), ke = null, Oe = C({}, [].concat(a(B), a(G), a(W), a(q))), De = Object.seal(Object.create(null, { tagNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, attributeNameCheck: { writable: true, configurable: false, enumerable: true, value: null }, allowCustomizedBuiltInElements: { writable: true, configurable: false, enumerable: true, value: false } })), Re = null, Ce = null, Le = true, Me = true, Ie = false, Ue = true, Fe = false, ze = false, He = false, je = false, Pe = false, Be = false, Ge = false, We = true, qe = false, Ye = "user-content-", $e = true, Ke = false, Ve = {}, Xe = null, Ze = C({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Je = null, Qe = C({}, ["audio", "video", "img", "source", "image", "track"]), et = null, tt = C({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), nt = "http://www.w3.org/1998/Math/MathML", rt = "http://www.w3.org/2000/svg", ot = "http://www.w3.org/1999/xhtml", at = ot, it = false, lt = null, ct = C({}, [nt, rt, ot], w), ut = ["application/xhtml+xml", "text/html"], st = "text/html", ft = null, mt = i2.createElement("form"), pt = function(e2) {
        return e2 instanceof RegExp || e2 instanceof Function;
      }, dt = function(t2) {
        ft && ft === t2 || (t2 && e(t2) === "object" || (t2 = {}), t2 = L(t2), ye = ye = ut.indexOf(t2.PARSER_MEDIA_TYPE) === -1 ? st : t2.PARSER_MEDIA_TYPE, ge = ye === "application/xhtml+xml" ? w : E, _e = ("ALLOWED_TAGS" in t2) ? C({}, t2.ALLOWED_TAGS, ge) : xe, ke = ("ALLOWED_ATTR" in t2) ? C({}, t2.ALLOWED_ATTR, ge) : Oe, lt = ("ALLOWED_NAMESPACES" in t2) ? C({}, t2.ALLOWED_NAMESPACES, w) : ct, et = ("ADD_URI_SAFE_ATTR" in t2) ? C(L(tt), t2.ADD_URI_SAFE_ATTR, ge) : tt, Je = ("ADD_DATA_URI_TAGS" in t2) ? C(L(Qe), t2.ADD_DATA_URI_TAGS, ge) : Qe, Xe = ("FORBID_CONTENTS" in t2) ? C({}, t2.FORBID_CONTENTS, ge) : Ze, Re = ("FORBID_TAGS" in t2) ? C({}, t2.FORBID_TAGS, ge) : {}, Ce = ("FORBID_ATTR" in t2) ? C({}, t2.FORBID_ATTR, ge) : {}, Ve = ("USE_PROFILES" in t2) && t2.USE_PROFILES, Le = t2.ALLOW_ARIA_ATTR !== false, Me = t2.ALLOW_DATA_ATTR !== false, Ie = t2.ALLOW_UNKNOWN_PROTOCOLS || false, Ue = t2.ALLOW_SELF_CLOSE_IN_ATTR !== false, Fe = t2.SAFE_FOR_TEMPLATES || false, ze = t2.WHOLE_DOCUMENT || false, Pe = t2.RETURN_DOM || false, Be = t2.RETURN_DOM_FRAGMENT || false, Ge = t2.RETURN_TRUSTED_TYPE || false, je = t2.FORCE_BODY || false, We = t2.SANITIZE_DOM !== false, qe = t2.SANITIZE_NAMED_PROPS || false, $e = t2.KEEP_CONTENT !== false, Ke = t2.IN_PLACE || false, Se = t2.ALLOWED_URI_REGEXP || Se, at = t2.NAMESPACE || ot, De = t2.CUSTOM_ELEMENT_HANDLING || {}, t2.CUSTOM_ELEMENT_HANDLING && pt(t2.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (De.tagNameCheck = t2.CUSTOM_ELEMENT_HANDLING.tagNameCheck), t2.CUSTOM_ELEMENT_HANDLING && pt(t2.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (De.attributeNameCheck = t2.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), t2.CUSTOM_ELEMENT_HANDLING && typeof t2.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (De.allowCustomizedBuiltInElements = t2.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Fe && (Me = false), Be && (Pe = true), Ve && (_e = C({}, a(P)), ke = [], Ve.html === true && (C(_e, I), C(ke, B)), Ve.svg === true && (C(_e, U), C(ke, G), C(ke, q)), Ve.svgFilters === true && (C(_e, F), C(ke, G), C(ke, q)), Ve.mathMl === true && (C(_e, H), C(ke, W), C(ke, q))), t2.ADD_TAGS && (_e === xe && (_e = L(_e)), C(_e, t2.ADD_TAGS, ge)), t2.ADD_ATTR && (ke === Oe && (ke = L(ke)), C(ke, t2.ADD_ATTR, ge)), t2.ADD_URI_SAFE_ATTR && C(et, t2.ADD_URI_SAFE_ATTR, ge), t2.FORBID_CONTENTS && (Xe === Ze && (Xe = L(Xe)), C(Xe, t2.FORBID_CONTENTS, ge)), $e && (_e["#text"] = true), ze && C(_e, ["html", "head", "body"]), _e.table && (C(_e, ["tbody"]), delete Re.tbody), p && p(t2), ft = t2);
      }, ht = C({}, ["mi", "mo", "mn", "ms", "mtext"]), yt = C({}, ["foreignobject", "desc", "title", "annotation-xml"]), gt = C({}, ["title", "style", "font", "a", "script"]), bt = C({}, U);
      C(bt, F), C(bt, z);
      var vt = C({}, H);
      C(vt, j);
      var Tt = function(e2) {
        var t2 = ae(e2);
        t2 && t2.tagName || (t2 = { namespaceURI: at, tagName: "template" });
        var n3 = E(e2.tagName), r3 = E(t2.tagName);
        return !!lt[e2.namespaceURI] && (e2.namespaceURI === rt ? t2.namespaceURI === ot ? n3 === "svg" : t2.namespaceURI === nt ? n3 === "svg" && (r3 === "annotation-xml" || ht[r3]) : Boolean(bt[n3]) : e2.namespaceURI === nt ? t2.namespaceURI === ot ? n3 === "math" : t2.namespaceURI === rt ? n3 === "math" && yt[r3] : Boolean(vt[n3]) : e2.namespaceURI === ot ? !(t2.namespaceURI === rt && !yt[r3]) && (!(t2.namespaceURI === nt && !ht[r3]) && (!vt[n3] && (gt[n3] || !bt[n3]))) : !(ye !== "application/xhtml+xml" || !lt[e2.namespaceURI]));
      }, Nt = function(e2) {
        A(r2.removed, { element: e2 });
        try {
          e2.parentNode.removeChild(e2);
        } catch (t2) {
          e2.remove();
        }
      }, At = function(e2, t2) {
        try {
          A(r2.removed, { attribute: t2.getAttributeNode(e2), from: t2 });
        } catch (e3) {
          A(r2.removed, { attribute: null, from: t2 });
        }
        if (t2.removeAttribute(e2), e2 === "is" && !ke[e2])
          if (Pe || Be)
            try {
              Nt(t2);
            } catch (e3) {
            }
          else
            try {
              t2.setAttribute(e2, "");
            } catch (e3) {
            }
      }, Et = function(e2) {
        var t2, n3;
        if (je)
          e2 = "<remove></remove>" + e2;
        else {
          var r3 = S(e2, /^[\r\n\t ]+/);
          n3 = r3 && r3[0];
        }
        ye === "application/xhtml+xml" && at === ot && (e2 = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + e2 + "</body></html>");
        var o3 = le ? le.createHTML(e2) : e2;
        if (at === ot)
          try {
            t2 = new g2().parseFromString(o3, ye);
          } catch (e3) {
          }
        if (!t2 || !t2.documentElement) {
          t2 = se.createDocument(at, "template", null);
          try {
            t2.documentElement.innerHTML = it ? ce : o3;
          } catch (e3) {
          }
        }
        var a2 = t2.body || t2.documentElement;
        return e2 && n3 && a2.insertBefore(i2.createTextNode(n3), a2.childNodes[0] || null), at === ot ? pe.call(t2, ze ? "html" : "body")[0] : ze ? t2.documentElement : a2;
      }, wt = function(e2) {
        return fe.call(e2.ownerDocument || e2, e2, m2.SHOW_ELEMENT | m2.SHOW_COMMENT | m2.SHOW_TEXT, null, false);
      }, St = function(e2) {
        return e2 instanceof y2 && (typeof e2.nodeName != "string" || typeof e2.textContent != "string" || typeof e2.removeChild != "function" || !(e2.attributes instanceof h2) || typeof e2.removeAttribute != "function" || typeof e2.setAttribute != "function" || typeof e2.namespaceURI != "string" || typeof e2.insertBefore != "function" || typeof e2.hasChildNodes != "function");
      }, _t = function(t2) {
        return e(s2) === "object" ? t2 instanceof s2 : t2 && e(t2) === "object" && typeof t2.nodeType == "number" && typeof t2.nodeName == "string";
      }, xt = function(e2, t2, n3) {
        he[e2] && T(he[e2], function(e3) {
          e3.call(r2, t2, n3, ft);
        });
      }, kt = function(e2) {
        var t2;
        if (xt("beforeSanitizeElements", e2, null), St(e2))
          return Nt(e2), true;
        var n3 = ge(e2.nodeName);
        if (xt("uponSanitizeElement", e2, { tagName: n3, allowedTags: _e }), e2.hasChildNodes() && !_t(e2.firstElementChild) && (!_t(e2.content) || !_t(e2.content.firstElementChild)) && O(/<[/\w]/g, e2.innerHTML) && O(/<[/\w]/g, e2.textContent))
          return Nt(e2), true;
        if (!_e[n3] || Re[n3]) {
          if (!Re[n3] && Dt(n3)) {
            if (De.tagNameCheck instanceof RegExp && O(De.tagNameCheck, n3))
              return false;
            if (De.tagNameCheck instanceof Function && De.tagNameCheck(n3))
              return false;
          }
          if ($e && !Xe[n3]) {
            var o3 = ae(e2) || e2.parentNode, a2 = oe(e2) || e2.childNodes;
            if (a2 && o3)
              for (var i3 = a2.length - 1;i3 >= 0; --i3)
                o3.insertBefore(R2(a2[i3], true), re2(e2));
          }
          return Nt(e2), true;
        }
        return e2 instanceof f2 && !Tt(e2) ? (Nt(e2), true) : n3 !== "noscript" && n3 !== "noembed" || !O(/<\/no(script|embed)/i, e2.innerHTML) ? (Fe && e2.nodeType === 3 && (t2 = e2.textContent, t2 = _(t2, be, " "), t2 = _(t2, ve, " "), t2 = _(t2, Te, " "), e2.textContent !== t2 && (A(r2.removed, { element: e2.cloneNode() }), e2.textContent = t2)), xt("afterSanitizeElements", e2, null), false) : (Nt(e2), true);
      }, Ot = function(e2, t2, n3) {
        if (We && (t2 === "id" || t2 === "name") && ((n3 in i2) || (n3 in mt)))
          return false;
        if (Me && !Ce[t2] && O(Ne, t2))
          ;
        else if (Le && O(Ae, t2))
          ;
        else if (!ke[t2] || Ce[t2]) {
          if (!(Dt(e2) && (De.tagNameCheck instanceof RegExp && O(De.tagNameCheck, e2) || De.tagNameCheck instanceof Function && De.tagNameCheck(e2)) && (De.attributeNameCheck instanceof RegExp && O(De.attributeNameCheck, t2) || De.attributeNameCheck instanceof Function && De.attributeNameCheck(t2)) || t2 === "is" && De.allowCustomizedBuiltInElements && (De.tagNameCheck instanceof RegExp && O(De.tagNameCheck, n3) || De.tagNameCheck instanceof Function && De.tagNameCheck(n3))))
            return false;
        } else if (et[t2])
          ;
        else if (O(Se, _(n3, we, "")))
          ;
        else if (t2 !== "src" && t2 !== "xlink:href" && t2 !== "href" || e2 === "script" || x(n3, "data:") !== 0 || !Je[e2]) {
          if (Ie && !O(Ee, _(n3, we, "")))
            ;
          else if (n3)
            return false;
        } else
          ;
        return true;
      }, Dt = function(e2) {
        return e2.indexOf("-") > 0;
      }, Rt = function(t2) {
        var n3, o3, a2, i3;
        xt("beforeSanitizeAttributes", t2, null);
        var l3 = t2.attributes;
        if (l3) {
          var c2 = { attrName: "", attrValue: "", keepAttr: true, allowedAttributes: ke };
          for (i3 = l3.length;i3--; ) {
            var u3 = n3 = l3[i3], s3 = u3.name, f3 = u3.namespaceURI;
            if (o3 = s3 === "value" ? n3.value : k(n3.value), a2 = ge(s3), c2.attrName = a2, c2.attrValue = o3, c2.keepAttr = true, c2.forceKeepAttr = undefined, xt("uponSanitizeAttribute", t2, c2), o3 = c2.attrValue, !c2.forceKeepAttr && (At(s3, t2), c2.keepAttr))
              if (Ue || !O(/\/>/i, o3)) {
                Fe && (o3 = _(o3, be, " "), o3 = _(o3, ve, " "), o3 = _(o3, Te, " "));
                var m3 = ge(t2.nodeName);
                if (Ot(m3, a2, o3)) {
                  if (!qe || a2 !== "id" && a2 !== "name" || (At(s3, t2), o3 = Ye + o3), le && e(b2) === "object" && typeof b2.getAttributeType == "function")
                    if (f3)
                      ;
                    else
                      switch (b2.getAttributeType(m3, a2)) {
                        case "TrustedHTML":
                          o3 = le.createHTML(o3);
                          break;
                        case "TrustedScriptURL":
                          o3 = le.createScriptURL(o3);
                      }
                  try {
                    f3 ? t2.setAttributeNS(f3, s3, o3) : t2.setAttribute(s3, o3), N(r2.removed);
                  } catch (e2) {
                  }
                }
              } else
                At(s3, t2);
          }
          xt("afterSanitizeAttributes", t2, null);
        }
      }, Ct = function e(t2) {
        var n3, r3 = wt(t2);
        for (xt("beforeSanitizeShadowDOM", t2, null);n3 = r3.nextNode(); )
          xt("uponSanitizeShadowNode", n3, null), kt(n3) || (n3.content instanceof l2 && e(n3.content), Rt(n3));
        xt("afterSanitizeShadowDOM", t2, null);
      };
      return r2.sanitize = function(e2) {
        var t2, n3, a2, i3, c2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if ((it = !e2) && (e2 = "<!-->"), typeof e2 != "string" && !_t(e2)) {
          if (typeof e2.toString != "function")
            throw D("toString is not a function");
          if (typeof (e2 = e2.toString()) != "string")
            throw D("dirty is not a string, aborting");
        }
        if (!r2.isSupported)
          return e2;
        if (He || dt(c2), r2.removed = [], typeof e2 == "string" && (Ke = false), Ke) {
          if (e2.nodeName) {
            var u3 = ge(e2.nodeName);
            if (!_e[u3] || Re[u3])
              throw D("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (e2 instanceof s2)
          (n3 = (t2 = Et("<!---->")).ownerDocument.importNode(e2, true)).nodeType === 1 && n3.nodeName === "BODY" || n3.nodeName === "HTML" ? t2 = n3 : t2.appendChild(n3);
        else {
          if (!Pe && !Fe && !ze && e2.indexOf("<") === -1)
            return le && Ge ? le.createHTML(e2) : e2;
          if (!(t2 = Et(e2)))
            return Pe ? null : Ge ? ce : "";
        }
        t2 && je && Nt(t2.firstChild);
        for (var f3 = wt(Ke ? e2 : t2);a2 = f3.nextNode(); )
          kt(a2) || (a2.content instanceof l2 && Ct(a2.content), Rt(a2));
        if (Ke)
          return e2;
        if (Pe) {
          if (Be)
            for (i3 = me.call(t2.ownerDocument);t2.firstChild; )
              i3.appendChild(t2.firstChild);
          else
            i3 = t2;
          return (ke.shadowroot || ke.shadowrootmod) && (i3 = de.call(o2, i3, true)), i3;
        }
        var m3 = ze ? t2.outerHTML : t2.innerHTML;
        return ze && _e["!doctype"] && t2.ownerDocument && t2.ownerDocument.doctype && t2.ownerDocument.doctype.name && O(ee, t2.ownerDocument.doctype.name) && (m3 = "<!DOCTYPE " + t2.ownerDocument.doctype.name + ">\n" + m3), Fe && (m3 = _(m3, be, " "), m3 = _(m3, ve, " "), m3 = _(m3, Te, " ")), le && Ge ? le.createHTML(m3) : m3;
      }, r2.setConfig = function(e2) {
        dt(e2), He = true;
      }, r2.clearConfig = function() {
        ft = null, He = false;
      }, r2.isValidAttribute = function(e2, t2, n3) {
        ft || dt({});
        var r3 = ge(e2), o3 = ge(t2);
        return Ot(r3, o3, n3);
      }, r2.addHook = function(e2, t2) {
        typeof t2 == "function" && (he[e2] = he[e2] || [], A(he[e2], t2));
      }, r2.removeHook = function(e2) {
        if (he[e2])
          return N(he[e2]);
      }, r2.removeHooks = function(e2) {
        he[e2] && (he[e2] = []);
      }, r2.removeAllHooks = function() {
        he = {};
      }, r2;
    }();
    return re;
  });
});

// assets/lib/_globals.ts
var store = new Map;

// /mnt/c/shared/projects/git/chatgpt-chatify/node_modules/@datkat21/html/dist/html.js
class Html {
  elm;
  constructor(elm) {
    if (elm instanceof HTMLElement) {
      this.elm = elm;
    } else {
      this.elm = document.createElement(elm || "div");
    }
  }
  text(val) {
    this.elm.innerText = val;
    return this;
  }
  html(val) {
    this.elm.innerHTML = val;
    return this;
  }
  cleanup() {
    this.elm.remove();
    return this;
  }
  query(selector) {
    return this.elm.querySelector(selector);
  }
  qs(query) {
    if (this.elm.querySelector(query)) {
      return Html.from(this.elm.querySelector(query));
    } else {
      return null;
    }
  }
  qsa(query) {
    if (this.elm.querySelector(query)) {
      return Array.from(this.elm.querySelectorAll(query)).map((e) => Html.from(e));
    } else {
      return null;
    }
  }
  id(val) {
    this.elm.id = val;
    return this;
  }
  class(...val) {
    for (let i = 0;i < val.length; i++) {
      this.elm.classList.toggle(val[i]);
    }
    return this;
  }
  classOn(...val) {
    for (let i = 0;i < val.length; i++) {
      this.elm.classList.add(val[i]);
    }
    return this;
  }
  classOff(...val) {
    for (let i = 0;i < val.length; i++) {
      this.elm.classList.remove(val[i]);
    }
    return this;
  }
  style(obj) {
    for (const key of Object.keys(obj)) {
      this.elm.style.setProperty(key, obj[key]);
    }
    return this;
  }
  styleJs(obj) {
    for (const key of Object.keys(obj)) {
      this.elm.style[key] = obj[key];
    }
    return this;
  }
  on(ev, cb) {
    this.elm.addEventListener(ev, cb);
    return this;
  }
  un(ev, cb) {
    this.elm.removeEventListener(ev, cb);
    return this;
  }
  appendTo(parent) {
    if (parent instanceof HTMLElement) {
      parent.appendChild(this.elm);
    } else if (parent instanceof Html) {
      parent.elm.appendChild(this.elm);
    } else if (typeof parent === "string") {
      document.querySelector(parent)?.appendChild(this.elm);
    }
    return this;
  }
  append(elem) {
    if (elem instanceof HTMLElement) {
      this.elm.appendChild(elem);
    } else if (elem instanceof Html) {
      this.elm.appendChild(elem.elm);
    } else if (typeof elem === "string") {
      const newElem = document.createElement(elem);
      this.elm.appendChild(newElem);
      return new Html(newElem.tagName);
    }
    return this;
  }
  appendMany(...elements) {
    for (const elem of elements) {
      this.append(elem);
    }
    return this;
  }
  clear() {
    this.elm.innerHTML = "";
    return this;
  }
  attr(obj) {
    for (let key in obj) {
      if (obj[key] !== null && obj[key] !== undefined) {
        this.elm.setAttribute(key, obj[key]);
      } else {
        this.elm.removeAttribute(key);
      }
    }
    return this;
  }
  val(str) {
    var x = this.elm;
    x.value = str;
    return this;
  }
  getText() {
    return this.elm.innerText;
  }
  getHtml() {
    return this.elm.innerHTML;
  }
  getValue() {
    return this.elm.value;
  }
  swapRef(elm) {
    this.elm = elm;
    return this;
  }
  static from(elm) {
    if (typeof elm === "string") {
      const element = Html.qs(elm);
      if (element === null)
        return null;
      else
        return element;
    } else {
      return new Html(elm);
    }
  }
  static qs(query) {
    if (document.querySelector(query)) {
      return Html.from(document.querySelector(query));
    } else {
      return null;
    }
  }
  static qsa(query) {
    if (document.querySelector(query)) {
      return Array.from(document.querySelectorAll(query)).map((e) => Html.from(e));
    } else {
      return null;
    }
  }
}

// assets/lib/modal.ts
class Modal {
  modal;
  content;
  closeBtn;
  overlay;
  elementsArray;
  constructor(content) {
    this.modal = new Html("div");
    this.modal.class("modal");
    this.modal.attr({ "aria-modal": "true", role: "dialog" });
    this.content = new Html("div");
    this.content.class("modal-content");
    this.content.appendTo(this.modal);
    if (typeof content === "string") {
      this.content.html(content);
    } else if (content instanceof HTMLElement) {
      this.content.append(content);
    } else if (content instanceof Html) {
      this.content.append(content.elm);
    }
    this.closeBtn = new Html("button");
    this.closeBtn.class("close-btn", "transparent");
    this.closeBtn.text("x");
    this.closeBtn.attr({ type: "button" });
    this.closeBtn.on("click", this.hide.bind(this));
    this.closeBtn.appendTo(this.content);
    this.overlay = new Html("div");
    this.overlay.class("modal-overlay");
    this.overlay.appendTo(this.modal);
    this.modal.on("keydown", (e) => {
      this.handleKeyDown(e);
    });
    const focusableElements = this.content.elm.querySelectorAll('a[href], button, textarea, input[type="text"], input[type="checkbox"], input[type="radio"], select');
    this.elementsArray = Array.prototype.slice.call(focusableElements);
    this.elementsArray.forEach((el) => {
      el.setAttribute("tabindex", "0");
    });
    this.elementsArray[0].addEventListener("keydown", (e) => {
      if (e.key === "Tab" && e.shiftKey) {
        e.preventDefault();
        this.elementsArray[this.elementsArray.length - 1].focus();
      }
    });
    this.elementsArray[this.elementsArray.length - 1].addEventListener("keydown", (e) => {
      if (e.key === "Tab" && !e.shiftKey) {
        e.preventDefault();
        this.elementsArray[0].focus();
      }
    });
    this.elementsArray[0].focus();
  }
  show() {
    this.modal.appendTo("body");
    this.modal.elm.focus();
    this.elementsArray[0].focus();
  }
  tempHide() {
    this.modal.style({ display: "none" });
  }
  tempShow() {
    this.modal.style({ display: "block" });
  }
  hide() {
    this.modal.cleanup();
  }
  handleKeyDown(e) {
    if (e.key === "Escape") {
      this.hide();
    }
  }
}

// assets/lib/ui/sidebar/settings.ts
function loadUserSettings(us = JSON.parse(localStorage.getItem("user-settings") || "{}")) {
  try {
    const userSettings = store.get("userSettings");
    if (us.promptPrefix !== undefined)
      userSettings["promptPrefix"] = us.promptPrefix;
    if (us.promptPrefixEnabled !== undefined)
      userSettings["promptPrefixEnabled"] = us.promptPrefixEnabled;
    if (us.timeZone !== undefined)
      userSettings["timeZone"] = us.timeZone;
    if (us.theme !== undefined)
      userSettings["theme"] = us.theme;
    if (us.username !== undefined)
      userSettings["username"] = us.username;
    if (us.includeUsername !== undefined)
      userSettings["includeUsername"] = us.includeUsername;
    if (us.chatViewType !== undefined)
      userSettings["chatViewType"] = us.chatViewType;
    if (us.showAvatars !== undefined)
      userSettings["showAvatars"] = us.showAvatars;
    if (us.showNames !== undefined)
      userSettings["showNames"] = us.showNames;
    if (us.showCopyButton !== undefined)
      userSettings["showCopyButton"] = us.showCopyButton;
    if (us.showEditButton !== undefined)
      userSettings["showEditButton"] = us.showEditButton;
    if (us.testMode !== undefined)
      userSettings["testMode"] = us.testMode;
    if (us.ctxLength !== undefined)
      userSettings["ctxLength"] = us.ctxLength;
    if (us.maxTokens !== undefined)
      userSettings["maxTokens"] = us.maxTokens;
    if (userSettings.theme !== undefined && userSettings.theme === "clean-dark")
      userSettings.theme = "azure";
    if (us.promptPrefix === false)
      userSettings["promptPrefix"] = "";
    document.documentElement.dataset.theme = userSettings.theme;
    document.documentElement.dataset.chatViewType = userSettings.chatViewType;
    document.documentElement.dataset.showAvatars = userSettings.showAvatars;
    document.documentElement.dataset.showNames = userSettings.showNames;
    document.documentElement.dataset.showCopyButton = userSettings.showCopyButton;
  } catch (e) {
  }
}
var saveUserSettings = function() {
  localStorage.setItem("user-settings", JSON.stringify(userSettings));
};
var userSettings = {
  promptPrefix: "",
  promptPrefixEnabled: true,
  timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone || false,
  theme: "clean-dark",
  username: "User",
  includeUsername: false,
  rememberContext: false,
  chatViewType: "cozy",
  showAvatars: true,
  showNames: true,
  showCopyButton: true,
  showEditButton: true,
  testMode: false,
  ctxLength: "3072",
  maxTokens: "2048"
};
store.set("userSettings", userSettings);
loadUserSettings();
function settingsBtn(container) {
  return new Html("button").text("Settings").class("fg").appendTo(container).on("click", () => {
    const manageSettingsDiv = new Html("div").class("row");
    const importSettingsBtn = new Html("button").class("fg-auto").text("Import Settings");
    const exportSettingsBtn = new Html("button").class("fg-auto").text("Export Settings");
    importSettingsBtn.on("click", () => {
      let modal1;
      const modalContainer = new Html("div").text("Are you sure you want to continue importing new settings?\nYou will lose ALL your prompts and saved settings.").append(new Html("div").classOn("fg-auto", "row").append(new Html("button").text("OK").classOn("danger", "fg-auto").on("click", () => {
        modal1.hide();
        const ta = new Html("textarea").attr({
          rows: "8",
          placeholder: "{ ... }"
        });
        const modalContent2 = new Html("div").text("Import JSON configuration data:").append(new Html("div").classOn("column").appendMany(ta, new Html("button").text("Attempt Import").classOn("fg-auto").on("click", () => {
          let json;
          try {
            json = JSON.parse(ta.getValue());
            loadUserSettings(json);
            if (typeof json["promptList"] !== "undefined") {
              localStorage.setItem("prompts", JSON.stringify(json["promptList"]));
            }
            modal22.hide();
            modal2.hide();
            store.get("userSettingsBtn").elm.click();
            saveUserSettings();
          } catch (e) {
            modal22.hide();
          }
        })));
        const modal22 = new Modal(modalContent2);
        modal22.show();
      })).append(new Html("button").text("Cancel").classOn("fg-auto").on("click", () => {
        modal1.hide();
      })));
      modal1 = new Modal(modalContainer);
      modal1.show();
    });
    exportSettingsBtn.on("click", () => {
      const ta = new Html("textarea").attr({
        rows: "8",
        placeholder: "{ ... }"
      });
      let modalContent2;
      try {
        ta.val(JSON.stringify(Object.assign(JSON.parse(localStorage.getItem("user-settings") || "{}"), {
          promptList: JSON.parse(localStorage.getItem("prompts") || "{}")
        })));
        modalContent2 = new Html("div").text("Here's your exported configuration data:").append(new Html("div").classOn("column").appendMany(ta, new Html("button").text("OK").classOn("fg-auto").on("click", () => {
          modal22.hide();
        })));
      } catch (e) {
        modalContent2 = new Html("div").text("Unable to export configuration due to parsing error:\n" + e).append(new Html("div").classOn("column").appendMany(new Html("button").text("OK").classOn("fg-auto").on("click", () => {
          modal22.hide();
        })));
      }
      const modal22 = new Modal(modalContent2);
      modal22.show();
    });
    manageSettingsDiv.appendMany(importSettingsBtn, exportSettingsBtn);
    const usernameInput = new Html("input").attr({
      type: "text",
      placeholder: "Username",
      maxlength: "24",
      minlength: "1"
    }).on("input", (e) => {
      localStorage.setItem("remembered-name", usernameInput.getValue());
      const result = /^[a-zA-Z0-9-]{0,24}$/.test(usernameInput.getValue());
      store.set("userName", result === true ? usernameInput.getValue() : "user");
      userSettings.username = store.get("userName");
      saveUserSettings();
      if (result === false)
        return e.target.value = "User";
    });
    store.set("usernameInput", usernameInput);
    usernameInput.val(localStorage.getItem("remembered-name") ?? "User");
    store.set("userName", /^[a-zA-Z0-9-]{0,24}$/.test(usernameInput.getValue()) ? usernameInput.getValue() : "user");
    const settings_extraContentWrapper = new Html("span");
    const settings_enableUserNameWrapper = new Html("span").appendTo(settings_extraContentWrapper).classOn("row");
    const settings_enableUserName = new Html("input").attr({
      id: "u",
      type: "checkbox",
      checked: userSettings.includeUsername === true ? true : undefined
    }).on("input", (e) => {
      userSettings.includeUsername = e.target.checked;
      saveUserSettings();
    }).appendTo(settings_enableUserNameWrapper);
    new Html("label").attr({
      for: "u"
    }).text("Include username?").appendTo(settings_enableUserNameWrapper);
    const settings_rememberContextWrapper = new Html("span").appendTo(settings_extraContentWrapper).classOn("row", "pt-0", "pb-0");
    const settings_rememberContextCheckbox = new Html("input").attr({
      id: "rcc",
      type: "checkbox",
      checked: userSettings.rememberContext === true ? true : undefined
    }).on("input", (e) => {
      userSettings.rememberContext = e.target.checked;
      saveUserSettings();
    }).appendTo(settings_rememberContextWrapper);
    new Html("label").attr({
      for: "rcc"
    }).text("Experimental: Remember context better").appendTo(settings_rememberContextWrapper);
    const settings_AppearanceContentWrapper = new Html("span");
    const settings_showAvatarsWrapper = new Html("span").appendTo(settings_AppearanceContentWrapper).classOn("row");
    const settings_showAvatarsCheckbox = new Html("input").attr({
      id: "sha",
      type: "checkbox",
      checked: userSettings.showAvatars === true ? true : undefined
    }).on("input", (e) => {
      document.documentElement.dataset.showAvatars = String(e.target.checked);
      userSettings.showAvatars = e.target.checked;
      saveUserSettings();
    }).appendTo(settings_showAvatarsWrapper);
    new Html("label").attr({
      for: "sha"
    }).text("Show avatars next to messages").appendTo(settings_showAvatarsWrapper);
    const settings_showNamesWrapper = new Html("span").appendTo(settings_AppearanceContentWrapper).classOn("row", "pt-0");
    const settings_showNamesCheckbox = new Html("input").attr({
      id: "shn",
      type: "checkbox",
      checked: userSettings.showNames === true ? true : undefined
    }).on("input", (e) => {
      document.documentElement.dataset.showNames = String(e.target.checked);
      userSettings.showNames = e.target.checked;
      saveUserSettings();
    }).appendTo(settings_showNamesWrapper);
    new Html("label").attr({
      for: "shn"
    }).text("Show names next to messages").appendTo(settings_showNamesWrapper);
    const settings_showCopyBtnWrapper = new Html("span").appendTo(settings_AppearanceContentWrapper).classOn("row", "pt-0");
    const settings_showCopyBtnCheckbox = new Html("input").attr({
      id: "shc",
      type: "checkbox",
      checked: userSettings.showCopyButton === true ? true : undefined
    }).on("input", (e) => {
      document.documentElement.dataset.showCopyButton = String(e.target.checked);
      userSettings.showCopyButton = e.target.checked;
      saveUserSettings();
    }).appendTo(settings_showCopyBtnWrapper);
    new Html("label").attr({
      for: "shc"
    }).text("Show 'Copy' button next to messages").appendTo(settings_showCopyBtnWrapper);
    const settings_showEditButtonWrapper = new Html("span").appendTo(settings_AppearanceContentWrapper).classOn("row", "pt-0", "pb-0");
    const settings_showEditButtonCheckbox = new Html("input").attr({
      id: "she",
      type: "checkbox",
      checked: userSettings.showEditButton === true ? true : undefined
    }).on("input", (e) => {
      document.documentElement.dataset.showEditButton = String(e.target.checked);
      userSettings.showEditButton = e.target.checked;
      saveUserSettings();
    }).appendTo(settings_showEditButtonWrapper);
    new Html("label").attr({
      for: "she"
    }).text("Show 'Edit' button next to messages").appendTo(settings_showEditButtonWrapper);
    const settings_ChatbotSettingsContentWrapper = new Html("span");
    const settings_testModeWrapper = new Html("span").appendTo(settings_ChatbotSettingsContentWrapper).class("pb-0").classOn("row");
    const settings_testModeCheckbox = new Html("input").attr({
      id: "tem",
      type: "checkbox",
      checked: userSettings.testMode === true ? true : undefined
    }).on("input", (e) => {
      userSettings.testMode = e.target.checked;
      saveUserSettings();
    }).appendTo(settings_testModeWrapper);
    new Html("label").attr({
      for: "tem"
    }).text("Enable Test Mode (fake responses for debugging)").appendTo(settings_testModeWrapper);
    const themeSelect = new Html("select").appendMany(new Html("option").text("Dark").attr({
      value: "dark",
      selected: userSettings.theme === "dark" ? true : undefined
    }), new Html("option").text("Light").attr({
      value: "light",
      selected: userSettings.theme === "light" ? true : undefined
    }), new Html("option").text("Midnight").attr({
      value: "amoled",
      selected: userSettings.theme === "amoled" ? true : undefined
    }), new Html("option").text("Lavender").attr({
      value: "lavender",
      selected: userSettings.theme === "lavender" ? true : undefined
    }), new Html("option").text("Maroon").attr({
      value: "maroon",
      selected: userSettings.theme === "maroon" ? true : undefined
    }), new Html("option").text("Tangerine").attr({
      value: "tangerine",
      selected: userSettings.theme === "tangerine" ? true : undefined
    }), new Html("option").text("Lemon").attr({
      value: "lemon",
      selected: userSettings.theme === "lemon" ? true : undefined
    }), new Html("option").text("Forest").attr({
      value: "forest",
      selected: userSettings.theme === "forest" ? true : undefined
    }), new Html("option").text("Azure").attr({
      value: "azure",
      selected: userSettings.theme === "azure" ? true : undefined
    }), new Html("option").text("Orchid").attr({
      value: "orchid",
      selected: userSettings.theme === "orchid" ? true : undefined
    }), new Html("option").text("Violet").attr({
      value: "violet",
      selected: userSettings.theme === "violet" ? true : undefined
    })).on("input", (e) => {
      document.documentElement.dataset.theme = String(e.target.value);
      userSettings.theme = e.target.value;
      saveUserSettings();
    });
    const chatSelect = new Html("select").appendMany(new Html("option").text("Cozy (default)").attr({
      value: "cozy",
      selected: userSettings.chatViewType === "cozy" ? true : undefined
    }), new Html("option").text("Compact").attr({
      value: "compact",
      selected: userSettings.chatViewType === "compact" ? true : undefined
    }), new Html("option").text("Bubbles").attr({
      value: "bubbles",
      selected: userSettings.chatViewType === "bubbles" ? true : undefined
    }), new Html("option").text("Flat Bubbles").attr({
      value: "flat-bubbles",
      selected: userSettings.chatViewType === "flat-bubbles" ? true : undefined
    })).on("input", (e) => {
      document.documentElement.dataset.chatViewType = e.target.value;
      userSettings.chatViewType = e.target.value;
      saveUserSettings();
    });
    const settings_togglePromptPrefixWrapper = new Html("span").appendTo(settings_ChatbotSettingsContentWrapper).classOn("row");
    function togglePpReadonly() {
      if (!settings_togglePromptPrefixCheckbox.elm.checked) {
        promptPrefixBox.elm.disabled = true;
      } else {
        promptPrefixBox.elm.disabled = false;
      }
    }
    const settings_togglePromptPrefixCheckbox = new Html("input").attr({
      id: "epp",
      type: "checkbox",
      checked: userSettings.promptPrefixEnabled === true ? true : ""
    }).on("input", (e) => {
      userSettings.promptPrefixEnabled = e.target.checked;
      togglePpReadonly();
      saveUserSettings();
    }).appendTo(settings_togglePromptPrefixWrapper);
    new Html("label").attr({
      for: "epp"
    }).text("Enable prompt prefix").appendTo(settings_togglePromptPrefixWrapper);
    const promptPrefixBox = new Html("textarea").attr({ rows: "4", placeholder: "<none>", resize: "none" }).html(userSettings.promptPrefix !== false ? userSettings.promptPrefix : "").on("input", (e) => {
      userSettings.promptPrefix = e.target.value.length > 0 ? e.target.value : false;
      saveUserSettings();
    });
    togglePpReadonly();
    const ctxLength = new Html("select").appendMany(new Html("option").text("25").attr({
      value: "25",
      selected: userSettings.ctxLength === "25" ? true : undefined
    }), new Html("option").text("32").attr({
      value: "32",
      selected: userSettings.ctxLength === "32" ? true : undefined
    }), new Html("option").text("64").attr({
      value: "64",
      selected: userSettings.ctxLength === "64" ? true : undefined
    }), new Html("option").text("128").attr({
      value: "128",
      selected: userSettings.ctxLength === "128" ? true : undefined
    }), new Html("option").text("256").attr({
      value: "256",
      selected: userSettings.ctxLength === "256" ? true : undefined
    }), new Html("option").text("512").attr({
      value: "512",
      selected: userSettings.ctxLength === "512" ? true : undefined
    }), new Html("option").text("1024").attr({
      value: "1024",
      selected: userSettings.ctxLength === "1024" ? true : undefined
    }), new Html("option").text("2048").attr({
      value: "2048",
      selected: userSettings.ctxLength === "2048" ? true : undefined
    }), new Html("option").text("2500").attr({
      value: "2500",
      selected: userSettings.ctxLength === "2500" ? true : undefined
    }), new Html("option").text("2750").attr({
      value: "2750",
      selected: userSettings.ctxLength === "2750" ? true : undefined
    }), new Html("option").text("3072").attr({
      value: "3072",
      selected: userSettings.ctxLength === "3072" ? true : undefined
    })).on("input", (e) => {
      userSettings.ctxLength = e.target.value;
      saveUserSettings();
    });
    const maxTokens = new Html("select").appendMany(new Html("option").text("25").attr({
      value: "25",
      selected: userSettings.maxTokens === "25" ? true : undefined
    }), new Html("option").text("32").attr({
      value: "32",
      selected: userSettings.maxTokens === "32" ? true : undefined
    }), new Html("option").text("64").attr({
      value: "64",
      selected: userSettings.maxTokens === "64" ? true : undefined
    }), new Html("option").text("128").attr({
      value: "128",
      selected: userSettings.maxTokens === "128" ? true : undefined
    }), new Html("option").text("256").attr({
      value: "256",
      selected: userSettings.maxTokens === "256" ? true : undefined
    }), new Html("option").text("512").attr({
      value: "512",
      selected: userSettings.maxTokens === "512" ? true : undefined
    }), new Html("option").text("1024").attr({
      value: "1024",
      selected: userSettings.maxTokens === "1024" ? true : undefined
    }), new Html("option").text("2048").attr({
      value: "2048",
      selected: userSettings.maxTokens === "2048" ? true : undefined
    })).on("input", (e) => {
      userSettings.maxTokens = e.target.value;
      saveUserSettings();
    });
    const modalContent = new Html("div").classOn("col").appendMany(manageSettingsDiv, new Html("fieldset").appendMany(new Html("legend").text("Personalization"), new Html("span").classOn("pb-2", "flex", "title").text("Username"), usernameInput, settings_extraContentWrapper), new Html("fieldset").appendMany(new Html("legend").text("Appearance"), new Html("span").classOn("pb-2", "flex", "title").text("Theme"), themeSelect, new Html("span").classOn("pb-2", "pt-2", "flex", "title").text("Chat Style"), chatSelect, new Html("span").classOn("pt-2", "flex", "title").text("Optional Appearance Features"), settings_AppearanceContentWrapper), new Html("fieldset").appendMany(new Html("legend").text("Chatbot Settings"), settings_togglePromptPrefixWrapper, new Html("span").classOn("pb-2", "flex", "title").text("Prompt prefix"), promptPrefixBox, new Html("span").classOn("pt-2", "pb-2", "flex", "title").text("Context Length (in tokens)"), ctxLength, new Html("span").classOn("pt-2", "pb-2", "flex", "title").text("Max Tokens (to generate)"), maxTokens, new Html("span").classOn("pt-2", "flex", "title").text("Test Mode"), settings_ChatbotSettingsContentWrapper));
    store.set("settings_enableUserName", settings_enableUserName);
    store.set("settings_rememberContextCheckbox", settings_rememberContextCheckbox);
    store.set("themeSelect", themeSelect);
    store.set("settings_showAvatarsCheckbox", settings_showAvatarsCheckbox);
    store.set("settings_showNamesCheckbox", settings_showNamesCheckbox);
    store.set("settings_showCopyBtnCheckbox", settings_showCopyBtnCheckbox);
    store.set("settings_showEditButtonCheckbox", settings_showEditButtonCheckbox);
    store.set("chatSelect", chatSelect);
    store.set("settings_togglePromptPrefixCheckbox", settings_togglePromptPrefixCheckbox);
    store.set("togglePpReadonly", togglePpReadonly);
    store.set("promptPrefixBox", promptPrefixBox);
    store.set("ctxLength", ctxLength);
    store.set("maxTokens", maxTokens);
    store.set("settings_testModeCheckbox", settings_testModeCheckbox);
    const modal2 = new Modal(modalContent);
    modal2.show();
  });
}

// assets/lib/util.ts
var highlight_min = __toESM(require_highlight_min(), 1);
function parseMarkdown(text) {
  let inCodeBlock = false;
  let parsedText = "";
  text = text.replace(/&/g, "&amp;");
  text = text.replace(/</g, "&lt;");
  text = text.replace(/>/g, "&gt;");
  const lines = text.split("\n");
  for (let i = 0;i < lines.length; i++) {
    const line = lines[i];
    if (inCodeBlock) {
      if (line.trim() === "```") {
        inCodeBlock = false;
        parsedText += "</code></pre>";
      } else {
        parsedText += line + "\n";
      }
    } else {
      if (line.trim().startsWith("```")) {
        inCodeBlock = true;
        const language = line.trim().slice(3);
        parsedText += `<pre><code class="language-${language}">`;
      } else {
        parsedText += parseMarkdownLine(line) + "\n";
      }
    }
  }
  if (inCodeBlock) {
    parsedText += "</code></pre>";
  }
  const codeTags = parsedText.match(/<code.+?class="language-(.*?)".*?>[\s\S]+?<\/code>/gim) || [];
  for (let i = 0;i < codeTags.length; i++) {
    const elem = document.createElement("div");
    elem.innerHTML = codeTags[i];
    const code = elem.textContent;
    const lang = codeTags[i].match(/class="language-([^"]+)"/i);
    const language = lang ? lang[1] : "plaintext";
    try {
      const highlightedCode = highlight_min.default.highlight(code, { language }).value;
      parsedText = parsedText.replace(codeTags[i], `<code class="language-${language}">${highlightedCode}</code>`);
    } catch (e) {
    }
  }
  return parsedText;
}
function parseMarkdownLine(line) {
  line = line.replace(/^# (.+)/gm, "<h1>$1</h1>");
  line = line.replace(/^## (.+)/gm, "<h2>$1</h2>");
  line = line.replace(/^### (.+)/gm, "<h3>$1</h3>");
  line = line.replace(/^#### (.+)/gm, "<h4>$1</h4>");
  line = line.replace(/^##### (.+)/gm, "<h5>$1</h5>");
  line = line.replace(/^###### (.+)/gm, "<h6>$1</h6>");
  line = line.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  line = line.replace(/\*(.+?)\*/g, "<em>$1</em>");
  line = line.replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>');
  line = line.replace(/!\[(.+?)\]\((.+?)\)/g, '<img src="$2" alt="$1">');
  line = line.replace(/`(.+?)`/g, "<code>$1</code>");
  line = "<p>" + line + "</p>";
  return line;
}
function toSnakeCase(name) {
  return name.trim().toLowerCase().replace(/\s+/g, "-");
}
function futureDate(fd) {
  const now = new Date;
  const diff = fd.getTime() - now.getTime();
  let timeString = "";
  if (diff <= 0) {
    timeString = "now";
  } else if (diff < 60000) {
    const seconds = Math.floor(diff / 1000);
    timeString = seconds === 1 ? `${seconds} second` : `${seconds} seconds`;
  } else if (diff < 3600000) {
    const minutes = Math.floor(diff / 60000);
    timeString = minutes === 1 ? `${minutes} minute` : `${minutes} minutes`;
  } else if (diff < 86400000) {
    const hours = Math.floor(diff / 3600000);
    timeString = hours === 1 ? `${hours} hour` : `${hours} hours`;
  } else if (diff < 604800000) {
    const days = Math.floor(diff / 86400000);
    timeString = days === 1 ? `${days} day` : `${days} days`;
  } else {
    timeString = fd.toDateString();
  }
  if (diff >= 0)
    timeString = "in " + timeString;
  return timeString;
}
function scrollDown() {
  var chatWindow = store.get("messagesContainer").elm;
  chatWindow.scrollTop = chatWindow.scrollHeight;
}
var PromptPickType;
(function(PromptPickType2) {
  PromptPickType2[PromptPickType2["Default"] = 0] = "Default";
  PromptPickType2[PromptPickType2["SingleAssistant"] = 1] = "SingleAssistant";
})(PromptPickType || (PromptPickType = {}));
var PromptType;
(function(PromptType2) {
  PromptType2["BuiltIn"] = "builtIn";
  PromptType2["Community"] = "community";
  PromptType2["Saved"] = "saved";
})(PromptType || (PromptType = {}));

// assets/lib/apiUsage.ts
async function checkRequests() {
  await fetch("/api/usage").then((j) => j.json()).then((j) => {
    apiUsage = j;
    store.set("apiUsage", apiUsage);
  });
}
function updateRequestsMessage() {
  const apiUsage = store.get("apiUsage");
  if (apiUsage.remaining !== null) {
    store.get("requestUi_text").text(`${apiUsage.used} of ${apiUsage.total} requests used (${apiUsage.plan}).`);
    store.get("requestUi_meter").attr({
      value: apiUsage.used,
      max: apiUsage.total
    });
    store.get("requestUi_meter").query("div").style.width = apiUsage.used / apiUsage.total * 100 + "%";
    store.get("requestUi_meter").classOff("extra-hidden");
    store.get("requestUi_hint").text(`Your quota resets ${futureDate(new Date(apiUsage.expires))}.`);
  } else {
    store.get("requestUi_text").text(`0 of ${apiUsage.total} requests used (${apiUsage.plan}).`);
    store.get("requestUi_meter").classOn("extra-hidden");
    store.get("requestUi_hint").text("");
  }
}
var apiUsage = {
  used: 0,
  remaining: 0,
  total: 0,
  expires: "",
  plan: "free"
};
await checkRequests();

// assets/lib/callApi.ts
var purify_min = __toESM(require_purify_min(), 1);
async function callAiStream(message, callback) {
  try {
    const userSettings2 = store.get("userSettings");
    const data = {
      user: store.get("userName"),
      useUserName: store.get("userSettings").includeUsername,
      prompt: message,
      botPrompt: store.get("select").elm.value,
      customSettings: {
        temp: parseFloat(store.get("customSettings_temp").elm.value),
        system: store.get("customSettings_systemPrompt").elm.value
      },
      rememberContext: store.get("userSettings").rememberContext,
      context: store.get("messageHistory").filter((m) => m !== null).slice(0, store.get("messageHistory").length - 1),
      userSettings: {
        timeZone: userSettings2.timeZone,
        promptPrefix: userSettings2.promptPrefixEnabled === true ? userSettings2.promptPrefix : "",
        testMode: userSettings2.testMode,
        ctxLength: userSettings2.ctxLength,
        maxTokens: userSettings2.maxTokens
      }
    };
    const options = {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(data)
    };
    let shouldContinue = 1;
    let error = null;
    const response = await fetch("/api/stream", options).then(async (r) => {
      if (!r.ok) {
        console.log("whoops");
        shouldContinue = 0;
        let errorData = await r.json();
        switch (errorData.errorCode) {
          case "too_many_requests":
            error = `You have used too many requests (${store.get("apiUsage").used} of ${store.get("apiUsage").total}) in the past hour. Please try again ${futureDate(new Date(store.get("apiUsage").expires))} from now.`;
            break;
          default:
            error = errorData.errorMessage;
            break;
        }
      } else
        return r;
    }).catch((e) => {
      shouldContinue = 0;
      error = e;
    });
    if (shouldContinue === 0) {
      console.log("shouldContinue FAILED");
      callback({
        unfilteredMsg: `<div id='AI_TEMP_ERR' class='error'>${error}</div>`
      });
      callback(true);
      return;
    }
    const stream = response.body;
    const reader = stream.getReader();
    let td = new TextDecoder;
    let buffer = "";
    window.addEventListener("chatify-premature-end", (e) => {
      callback(true);
    });
    store.set("currentSocket", reader);
    reader.read().then(async function processResult(result) {
      if (result.done) {
        return;
      }
      let r = td.decode(result.value);
      buffer += r.replace(/data:/g, "");
      const events = buffer.split(`\n`);
      buffer = events.pop()?.toString();
      for (const event of events) {
        try {
          const parsedEvent = JSON.parse(event);
          if (parsedEvent.type === "done") {
            callback(true);
            break;
          } else if (parsedEvent.type === "error") {
            let msg = parsedEvent.data;
            switch (msg) {
              case "invalid_api_key":
                msg = "The owner of this instance has not set up their API key properly, this is not a problem on your end.";
                break;
              case "too_many_requests":
                break;
            }
            callback({
              unfilteredMsg: `<div id='AI_TEMP_ERR' class='error'>Something went wrong: ${msg}</div>`
            });
            callback(true);
            return;
          } else if (parsedEvent.type === "inc") {
            await new Promise((resolve) => {
              setTimeout(resolve, 0);
            });
            callback({ msg: parsedEvent.data.replace(/\\n/g, "\n") });
          }
        } catch (err) {
        }
      }
      return reader.read().then(processResult);
    }).catch((err) => {
      console.error(err);
      callback({
        unfilteredMsg: `<div id='AI_TEMP_ERR' class='error'>Sorry, but there was an error while loading the response: ${err}</div>`
      });
      return callback(true);
    });
  } catch (e) {
    console.error(e);
    callback({
      unfilteredMsg: `<div id='AI_TEMP_ERR' class='error'>Sorry, but there was an error while loading the response: ${e}</div>`
    });
    return callback(true);
  }
}
async function callAiMessage(ai, message) {
  return new Promise(async (res, rej) => {
    let result = "";
    let x = ai.querySelector(".data .text");
    if (x !== null) {
      x.innerHTML = "";
    }
    ai.classList.add("thinking");
    let messages = [];
    callAiStream(message, (r) => {
      if (r === true) {
        ai.classList.remove("thinking");
        window.messages = messages;
        window.dispatchEvent(new CustomEvent("chatify-message-complete", {
          detail: { data: result }
        }));
        return res(result);
      }
      if (r === false) {
        if (x !== null)
          x.innerHTML = "";
        return;
      }
      if (r.unfilteredMsg) {
        result += r.unfilteredMsg;
        if (x !== null)
          x.innerHTML = result;
        return;
      }
      if (!r.msg)
        return console.log("?!");
      result += r.msg;
      if (x !== null)
        x.innerHTML = purify_min.default.sanitize(parseMarkdown(result));
      scrollDown();
      window.sourceMessage = result;
      window.previousMessage = r;
      window.finalHtml = x !== null ? x.innerHTML : null;
    });
  });
}

// assets/lib/ui/icons.ts
var ICONS = {
  trashCan: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>',
  chevron: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>',
  checkMark: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>',
  stop: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>',
  send: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>',
  retry: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>',
  copy: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>',
  edit: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>'
};

// assets/lib/ui/messages.ts
function autoExpandTextArea() {
  const inputArea = store.get("inputArea");
  inputArea.elm.style.height = "auto";
  inputArea.elm.style.height = inputArea.elm.scrollHeight + 2 + "px";
  const inputAreaHeight = inputArea.elm.offsetHeight;
  store.get("messagesContainer").elm.style.paddingBottom = `${inputAreaHeight + 12}px`;
}
function setupMessages() {
  const messagesWrapper = new Html("div").class("messages-wrapper").style({
    display: "flex",
    flexDirection: "row",
    gap: "8px",
    alignItems: "flex-end"
  });
  const messagesContainer = new Html("div").class("messages").appendTo(messagesWrapper);
  store.set("messagesContainer", messagesContainer);
  const inputAreaWrapper = new Html("div").classOn("row", "py-0", "align-end").appendTo(messagesWrapper);
  const inputArea = new Html("textarea").classOn("fg").attr({ type: "text", placeholder: "Message", rows: "1" }).style({ resize: "vertical", "min-height": "34px" }).appendTo(inputAreaWrapper);
  inputArea.style({ height: "35px" });
  const sendButton = new Html("button").html(ICONS.send).classOn("fg-auto").appendTo(inputAreaWrapper);
  store.set("sendButton", sendButton);
  messagesWrapper.appendTo("body");
  store.set("messagesWrapper", messagesWrapper);
  inputArea.elm.addEventListener("input", autoExpandTextArea);
  inputArea.elm.addEventListener("change", autoExpandTextArea);
  window.addEventListener("resize", autoExpandTextArea);
  const isMobile = /Mobi/.test(navigator.userAgent);
  if (!isMobile) {
    inputArea.elm.addEventListener("keydown", (e) => {
      if ((e.code || e.key) === "Enter" && !e.shiftKey) {
        e.preventDefault();
        if (e.target.value) {
          startTextGeneration();
        }
      }
    });
  }
  store.set("inputArea", inputArea);
}

// assets/lib/ui/state.ts
var purify_min2 = __toESM(require_purify_min(), 1);

// assets/lib/assistant.ts
function saveAssistant(id, obj) {
  let prompts = {};
  try {
    let p = localStorage.getItem("prompts");
    if (p === null)
      p = "{}";
    prompts = JSON.parse(p);
  } catch (e) {
    alert("Error parsing prompts from localStorage!");
  }
  prompts[id] = obj;
  localStorage.setItem("prompts", JSON.stringify(prompts));
}
function loadAssistant(id = null) {
  let prompts = {};
  try {
    let p = localStorage.getItem("prompts");
    if (p === null)
      p = "{}";
    prompts = JSON.parse(p);
  } catch (e) {
    alert("Error parsing prompts from localStorage!");
  }
  if (id === null) {
    return prompts;
  } else {
    return prompts[id];
  }
}
function deleteAssistant(id) {
  let prompts = {};
  try {
    let p = localStorage.getItem("prompts");
    if (p === null)
      p = "{}";
    prompts = JSON.parse(p);
  } catch (e) {
    alert("Error parsing prompts from localStorage!");
  }
  delete prompts[id];
  localStorage.setItem("prompts", JSON.stringify(prompts));
}

// assets/scripts/fuse.esm.js
var isArray = function(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
};
var baseToString = function(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
};
var toString = function(value) {
  return value == null ? "" : baseToString(value);
};
var isString = function(value) {
  return typeof value === "string";
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isBoolean = function(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
};
var isObject = function(value) {
  return typeof value === "object";
};
var isObjectLike = function(value) {
  return isObject(value) && value !== null;
};
var isDefined = function(value) {
  return value !== undefined && value !== null;
};
var isBlank = function(value) {
  return !value.trim().length;
};
var getTag = function(value) {
  return value == null ? value === undefined ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
};
var createKey = function(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
};
var createKeyPath = function(key) {
  return isArray(key) ? key : key.split(".");
};
var createKeyId = function(key) {
  return isArray(key) ? key.join(".") : key;
};
var get = function(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length;i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
};
var norm = function(weight = 1, mantissa = 3) {
  const cache = new Map;
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
};
var createIndex = function(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
};
var parseIndex = function(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
};
var computeScore$1 = function(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
};
var convertMaskToIndices = function(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length;i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
};
var search = function(text, pattern, patternAlphabet, {
  location: location2 = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location2, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0;i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish;j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(0.001, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
};
var createPatternAlphabet = function(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length;i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
};
var getMatch = function(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
};
var parseQuery = function(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length;i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
};
var register = function(...args) {
  registeredSearchers.push(...args);
};
var createSearcher = function(pattern, options) {
  for (let i = 0, len = registeredSearchers.length;i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
};
var parse = function(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
};
var computeScore = function(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
    });
    result.score = totalScore;
  });
};
var transformMatches = function(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
};
var transformScore = function(result, data) {
  data.score = result.score;
};
var format = function(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
};
var INFINITY = 1 / 0;
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;

class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
var MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
var BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
var AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;

class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size();i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
var MAX_BITS = 32;

class BitapSearch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location: location2,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location: location2,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location2 + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}

class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}

class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}

class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}

class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}

class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}

class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
}

class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
}

class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location: location2,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
}

class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location2 = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text.indexOf(this.pattern, location2)) > -1) {
      location2 = index + patternLen;
      indices.push([index, location2 - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
var MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location: location2 = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location: location2,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length;i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length;j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
var registeredSearchers = [];
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});

class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length;i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length;i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(...this._findMatches({
          key,
          value: item[keyIndex],
          searcher
        }));
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// assets/lib/promptHandling.ts
async function getPrompts() {
  const prompts = await fetch("/api/prompts").then((j) => j.json());
  window.prompts = JSON.parse(JSON.stringify(prompts));
  store.set("prompts", prompts);
  return prompts;
}
function importAndLoadPrompt(value, cb) {
  try {
    const r = JSON.parse(value);
    if (r.system && r.temp) {
      if (r.name === undefined)
        r.name = false;
      if (r.avatar === undefined)
        r.avatar = false;
      store.get("customSettings_systemPrompt").elm.value = r.system;
      store.get("customSettings_temp").elm.value = r.temp;
      store.set("aiNameOverride", r.name || "");
      store.set("aiAvatarOverride", r.avatar || "");
      store.get("customSettings_overrideName").elm.value = store.get("aiNameOverride");
      store.get("customSettings_overrideAvatar").elm.value = store.get("aiAvatarOverride");
      cb();
    } else {
      cb();
      const btn_modalContent = new Html("div").text('Something may be wrong with the prompt, please make sure it is a valid JSON object with "system" and "temp".');
      const btn_modal = new Modal(btn_modalContent);
      btn_modal.show();
    }
  } catch (e) {
    cb();
    console.error(e);
    const btn_modalContent = new Html("div").html("Failed to load prompt. Please make sure it is a valid JSON string!<br>Error code: " + e);
    const btn_modal = new Modal(btn_modalContent);
    btn_modal.show();
  }
}

// assets/lib/ui/sidebar/promptPick.ts
function setPrompt(prp, mkMsg = true) {
  const select = store.get("select");
  select.elm.value = prp.id;
  store.get("selectPromptBtn").text(prp.label);
  selectedPrompt = prp;
  if (select.elm.value === "custom") {
    store.get("customSettingsWrapper").classOff("hidden");
  } else {
    store.get("customSettingsWrapper").classOn("hidden");
  }
  if (mkMsg === true) {
    if (prp.greetingMessages && Array.isArray(prp.greetingMessages)) {
      const m = prp.greetingMessages[Math.floor(Math.random() * prp.greetingMessages.length)];
      const index = store.get("messageHistory").push({
        role: "assistant",
        clientSide: true,
        type: select.elm.value,
        content: m
      }) - 1;
      const msg = makeMessage(1, "", index, prp, true);
      let str = "";
      store.get("selectPromptBtn").elm.disabled = true;
      let i = 0;
      const update = () => {
        if (i >= m.length) {
          store.get("selectPromptBtn").elm.disabled = false;
        } else {
          str += m[i];
          updateMessage(msg.elm, str);
          i++;
          setTimeout(update, Math.floor(Math.random() * 15) / 4);
        }
      };
      setTimeout(update, Math.floor(Math.random() * 15) / 4);
    }
  }
  return selectedPrompt;
}
function promptPick(focusTab = "builtIn", type = PromptPickType.Default, mkMsg = true) {
  return new Promise((resolve, reject) => {
    const tabsButtons = new Html("div").classOn("row").classOn("fg");
    const tabsGroup = new Html("div").classOn("fg-max");
    function tabTransition(btn, tab) {
      promptsTab_builtInTab.classOn("extra-hidden");
      promptsTab_communityTab.classOn("extra-hidden");
      promptsTab_savedTab.classOn("extra-hidden");
      promptsTab_builtInButton.classOff("selected");
      promptsTab_communityButton.classOff("selected");
      promptsTab_savedButton.classOff("selected");
      btn.classOn("selected");
      tab.classOff("extra-hidden");
    }
    function setTabContent(tab, prompts, savedPromptsShowDeleteButton = false) {
      function makePrompt(prp) {
        return new Html("div").classOn("prompt").appendMany(new Html("div").classOn("assistant").appendMany(new Html("div").classOn("who").attr({
          "data-mode": String(prp.id),
          style: prp.avatar !== null && prp.avatar !== undefined ? `--icon:url(${prp.avatar})` : "--icon:url(./assets/avatars/builtin/custom.svg)"
        }).appendMany(new Html("div").classOn("icon"), new Html("div").classOn("name").attr({ title: String(prp.id) }).text(String(prp.label))), new Html("div").classOn("greeting").text(String(prp.greeting)), new Html("div").classOn("hint").text(String(prp.hint))), new Html("div").classOn("controls").appendMany(new Html("button").text("Select").on("click", () => {
          if (prp.type !== undefined && prp.type !== PromptType.Saved) {
            setPrompt(prp, mkMsg);
            store.set("currentPrompt", prp);
            modal4.hide();
            resolve(prp);
          } else {
            setPrompt({ id: "custom", label: "Custom" }, mkMsg);
            store.set("loadedCustomPrompt", assistantObj[prp.id?.toString()]);
            store.get("loadedCustomPrompt").id = prp.id;
            const z = JSON.stringify(store.get("loadedCustomPrompt"));
            importAndLoadPrompt(z, () => {
              modal4.hide();
              resolve(selectedPrompt);
            });
          }
        }), savedPromptsShowDeleteButton === true ? new Html("button").text("Delete").classOn("danger").on("click", () => {
          if (prp.type !== PromptType.Saved) {
            setPrompt(prp, mkMsg);
            modal4.hide();
          } else {
            let mdl;
            const modalContainer = new Html("div").appendMany(new Html("p").class("mt-0").text("Are you sure you want to delete this prompt?"), new Html("div").classOn("prompt-box").append(new Html("div").classOn("prompt").append(new Html("div").classOn("assistant").appendMany(new Html("div").classOn("who").attr({
              "data-mode": String(prp.id),
              style: prp.avatar !== null && prp.avatar !== undefined ? `--icon:url(${prp.avatar})` : "--icon:url(./assets/avatars/builtin/custom.svg)"
            }).appendMany(new Html("div").classOn("icon"), new Html("div").classOn("name").attr({ title: String(prp.id) }).text(String(prp.label))), new Html("div").classOn("greeting").text(String(prp.greeting)), new Html("div").classOn("hint").text(String(prp.hint))))), new Html("div").classOn("fg-auto", "row", "pb-0").append(new Html("button").text("OK").classOn("fg-auto").on("click", () => {
              deleteAssistant(prp.id);
              mdl.hide();
              modal4.hide();
              return promptPick("saved");
            })).append(new Html("button").text("Cancel").classOn("danger", "fg-auto").on("click", () => {
              mdl.hide();
            })));
            mdl = new Modal(modalContainer);
            mdl.show();
          }
        }) : null));
      }
      const container = new Html("div").classOn("prompt-box").appendTo(tab);
      const controlsBox = new Html("div").classOn("prompt-box").appendTo(container);
      const promptBox = new Html("div").classOn("prompt-box").appendTo(container);
      const searchBar = new Html("input").attr({ type: "text", placeholder: "Search..." }).on("input", (e) => {
        const options = {
          keys: ["name", "system", "greeting", "displayName", "hint"],
          shouldSort: true
        };
        const fuse = new Fuse(prompts, options);
        const term = e.target.value;
        if (term === "") {
          promptBox.html("");
          prompts.forEach((prp) => {
            const i = makePrompt(prp);
            i.appendTo(promptBox);
          });
          return;
        }
        const searchResults = fuse.search(term);
        promptBox.html("");
        if (searchResults.length > 0)
          searchResults.forEach((r) => {
            const i = r.refIndex;
            makePrompt(prompts[i]).appendTo(promptBox);
          });
        else
          promptBox.html(`<i style="color:var(--text-color-accent);">Your search had no results.</i>`);
      });
      controlsBox.appendMany(new Html("div").class("row", "py-0", "wrap").appendMany(new Html("button").text("Create your own prompt").classOn("fg-auto").on("click", () => {
        setPrompt({ id: "custom", label: "Custom" }, mkMsg);
        modal4.hide();
        resolve("custom");
      }), new Html("button").text("Scroll to bottom").classOn("transparent", "fg-auto").on("click", () => {
        modal4.modal.elm.scrollTo({
          top: modal4.modal.elm.scrollHeight,
          behavior: "smooth"
        });
      }), type === PromptPickType.Default ? new Html("button").text(`Multi-prompt ${store.get("mpState") === true ? "(On)" : "(Off)"}`).append(new Html("span").class("badge").text("BETA")).classOn("transparent", "fg-auto").on("click", () => {
        modal4.hide();
        multiPromptUi();
      }) : undefined), searchBar);
      prompts.forEach((prp) => {
        const i = makePrompt(prp);
        i.appendTo(promptBox);
      });
    }
    const promptsTab_builtInButton = new Html("button").classOn("tab-selector").classOn("fg").text("Built-In").on("click", () => {
      tabTransition(promptsTab_builtInButton, promptsTab_builtInTab);
    }).appendTo(tabsButtons);
    const promptsTab_builtInTab = new Html("div").classOn("tab").appendTo(tabsGroup);
    setTabContent(promptsTab_builtInTab, store.get("prompts").filter((p) => p.type === PromptType.BuiltIn));
    const promptsTab_communityButton = new Html("button").classOn("tab-selector").classOn("fg").text("Community").on("click", () => {
      tabTransition(promptsTab_communityButton, promptsTab_communityTab);
    }).appendTo(tabsButtons);
    const promptsTab_communityTab = new Html("div").classOn("tab").appendTo(tabsGroup);
    setTabContent(promptsTab_communityTab, store.get("prompts").filter((p) => p.type === PromptType.Community).sort((a, b) => {
      if (a.hint !== undefined && b.hint !== undefined) {
        if (a.hint > b.hint) {
          return -1;
        }
        if (a.hint < b.hint) {
          return 1;
        }
      }
      return 0;
    }));
    const promptsTab_savedButton = new Html("button").classOn("tab-selector").classOn("fg").text("Saved").on("click", () => {
      tabTransition(promptsTab_savedButton, promptsTab_savedTab);
    }).appendTo(tabsButtons);
    const promptsTab_savedTab = new Html("div").classOn("tab").appendTo(tabsGroup);
    const assistantObj = loadAssistant();
    store.set("assistantObj", assistantObj);
    let assistantKeys = Object.keys(assistantObj);
    let assistantArray = Object.values(assistantObj);
    let assistantHtml = assistantKeys.map((key) => {
      const p = assistantObj[key];
      return {
        avatar: p.avatar !== false ? p.avatar : undefined,
        displayName: p.name !== false ? p.name : undefined,
        greeting: p.system,
        hint: "This is one of your custom prompts.",
        id: key,
        label: p.name !== false ? p.name : "null",
        type: PromptType.Saved
      };
    });
    setTabContent(promptsTab_savedTab, assistantHtml, true);
    const modalContent = new Html("div").class("fg").append(new Html("span").text("Prompt selection")).append(new Html("div").class("flex-wrap").appendMany(tabsButtons).appendMany(tabsGroup));
    if (focusTab !== undefined) {
      switch (focusTab) {
        case "builtIn":
          tabTransition(promptsTab_builtInButton, promptsTab_builtInTab);
          break;
        case "community":
          tabTransition(promptsTab_communityButton, promptsTab_communityTab);
          break;
        case "saved":
          tabTransition(promptsTab_savedButton, promptsTab_savedTab);
          break;
      }
    } else
      tabTransition(promptsTab_builtInButton, promptsTab_builtInTab);
    const modal4 = new Modal(modalContent);
    modal4.show();
    modal4.modal.qs(".close-btn")?.on("click", () => {
      resolve(false);
    });
  });
}
var selectedPrompt = {};

// assets/lib/ui/sidebar/multiPrompt.ts
function mpGetPromptsSelected() {
  return store.get("mpPromptsSelected");
}
function multiPromptUi() {
  const mpPromptsList = new Html("div").class("prompt-box");
  function renderPromptsList() {
    function makePrompt(prp, id) {
      return new Html("div").classOn("prompt").appendMany(new Html("div").classOn("assistant").appendMany(new Html("div").classOn("who").attr({
        "data-mode": String(prp.id),
        style: prp.avatar !== null && prp.avatar !== undefined ? `--icon:url(${prp.avatar})` : "--icon:url(./assets/avatars/builtin/custom.svg)"
      }).appendMany(new Html("div").classOn("icon"), new Html("div").classOn("name").attr({ title: String(prp.id) }).text(String(prp.label))), new Html("div").classOn("greeting").text(String(prp.greeting)), new Html("div").classOn("hint").text(String(prp.hint))), new Html("div").classOn("controls").appendMany(new Html("button").text("Remove").classOn("danger").on("click", () => {
        mpGetPromptsSelected().splice(id, 1);
        renderPromptsList();
      })));
    }
    mpPromptsList.clear();
    mpGetPromptsSelected().forEach((p, i) => {
      mpPromptsList.append(makePrompt(p, i));
    });
    if (mpGetPromptsSelected().length > 5) {
      mpAddButton.attr({ disabled: true });
    } else {
      mpAddButton.attr({ disabled: undefined });
    }
    mpInfoCount.text(`You're using ${mpGetPromptsSelected().length} of 6 prompts.`);
  }
  const mpInfoContainer = new Html("div").class("row");
  const getMpState = () => store.get("mpState") === true ? "Disable" : "Enable";
  const mpToggleButton = new Html("button").class("fg-auto").text(getMpState()).on("click", (e) => {
    const state3 = !store.get("mpState");
    store.set("mpState", state3);
    mpToggleButton.text(getMpState());
  }).appendTo(mpInfoContainer);
  const mpAddButton = new Html("button").text("Add").appendTo(mpInfoContainer).class("fg-auto").on("click", async () => {
    modal5.tempHide();
    let prp = await promptPick("builtIn", PromptPickType.SingleAssistant, false);
    modal5.tempShow();
    if (prp === false)
      return;
    if (prp === "custom")
      return;
    const f = mpGetPromptsSelected();
    if (f.find((p) => p.id === prp.id)) {
      return;
    }
    if (prp.id === "custom") {
      let CustomPrompt2 = store.get("loadedCustomPrompt");
      prp = {
        avatar: CustomPrompt2.avatar !== false ? String(CustomPrompt2.avatar) : "./assets/avatars/builtin/custom.svg",
        label: String(CustomPrompt2.name),
        displayName: String(CustomPrompt2.name),
        greeting: String(CustomPrompt2.system),
        hint: `This is a custom prompt with ID ${String(CustomPrompt2.id)}.`
      };
    }
    mpGetPromptsSelected().push(prp);
    console.log(mpGetPromptsSelected());
    renderPromptsList();
  });
  const mpInfoCount = new Html("span").appendTo(mpInfoContainer);
  const mpDiv = new Html("div").class("column").appendMany(mpInfoContainer, mpPromptsList);
  const modalContainer = new Html("div").class("column").appendMany(new Html("span").text("Multi-prompt").appendMany(new Html("span").class("badge").text("BETA")), mpDiv);
  const modal5 = new Modal(modalContainer);
  modal5.show();
  renderPromptsList();
}
store.set("mpPromptsSelected", []);
store.set("mpState", false);

// assets/lib/ui/state.ts
function makeMessage(side = 0, data, messageIndex, prompt = null, isSystem = false, actuallyGoesToMessageHistory = true) {
  if (messageIndex === undefined)
    messageIndex = store.get("messageHistory").length;
  const msg = new Html("div").class("message");
  const messageContentWrapper = new Html("div").class("wrapper").appendTo(msg);
  const icon = new Html("div").class("icon").appendTo(messageContentWrapper);
  const dataContainer = new Html("div").class("data", "fg-max").appendTo(messageContentWrapper);
  const extra = new Html("div").class("column").appendTo(msg);
  const uname = new Html("div").class("name").appendTo(dataContainer);
  const text = new Html("div").class("text").appendTo(dataContainer);
  switch (side) {
    case 0:
      msg.class("user");
      dataContainer.class("muted");
      text.html(data);
      if (prompt) {
        uname.text(String(prompt));
      } else {
        uname.text(store.get("userName"));
      }
      break;
    case 1:
      msg.class("gpt");
      const select = store.get("select");
      msg.elm.dataset.mode = select.elm.value;
      uname.text(select.elm.querySelector('select option[value="' + select.elm.value + '"]').value);
      prompt = prompt;
      if (prompt !== null) {
        if (prompt.avatar !== null && prompt.avatar !== undefined) {
          msg.style({ "--icon": "url(" + prompt.avatar + ")" });
        } else {
          msg.style({ "--icon": "url(./assets/avatars/builtin/custom.svg)" });
        }
        if (prompt.displayName !== null && prompt.displayName !== undefined) {
          uname.text(prompt.displayName);
        }
      }
      if (select.elm.value === "custom") {
        if (store.get("aiAvatarOverride") !== false) {
          icon.style({
            "background-image": "url(" + store.get("aiAvatarOverride") + ")"
          });
        }
        if (store.get("aiNameOverride") !== false) {
          uname.text(store.get("aiNameOverride"));
        }
      }
      if (isSystem === true)
        uname.elm.innerHTML += '<span class="badge">System</span>';
      break;
  }
  if (isSystem === false || actuallyGoesToMessageHistory === true) {
    extra.appendMany(new Html("button").class("transparent", "fg-auto", "small").html(ICONS.trashCan).on("click", () => {
      let modal6;
      const modalContainer = new Html("div").text("Are you sure you want to delete this message?").append(new Html("div").classOn("fg-auto", "row").append(new Html("button").text("OK").classOn("fg-auto").on("click", () => {
        store.get("messageHistory")[messageIndex] = null;
        window.mh = store.get("messageHistory");
        msg.cleanup();
        modal6.hide();
      })).append(new Html("button").text("Cancel").classOn("danger", "fg-auto").on("click", () => {
        modal6.hide();
      })));
      modal6 = new Modal(modalContainer);
      modal6.show();
    }), new Html("button").class("transparent", "fg-auto", "small").html(ICONS.copy).on("click", () => {
      let text2 = store.get("messageHistory")[messageIndex].content;
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text2);
      } else {
        var textarea = document.createElement("textarea");
        textarea.value = text2;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
      }
    }), new Html("button").class("transparent", "fg-auto", "small").html(ICONS.edit).on("click", () => {
      let text2 = store.get("messageHistory")[messageIndex].content;
      const textArea = new Html("textarea").classOn("mt-1").attr({ rows: "8", placeholder: "Message content is empty" }).val(text2);
      let modal6;
      const modalContainer = new Html("div").text(`Edit Message #${messageIndex}`).appendMany(textArea, new Html("div").classOn("fg-auto", "row").append(new Html("button").text("OK").classOn("fg-auto").on("click", () => {
        let editedValue = textArea.getValue();
        updateMessage(msg.elm, editedValue);
        store.get("messageHistory")[messageIndex].content = editedValue;
        modal6.hide();
      })).append(new Html("button").text("Cancel").classOn("danger", "fg-auto").on("click", () => {
        modal6.hide();
      })));
      modal6 = new Modal(modalContainer);
      modal6.show();
    }));
  } else {
    extra.append(new Html("button").class("transparent").html(ICONS.trashCan).on("click", () => {
      let modal6;
      const modalContainer = new Html("div").text("Are you sure you want to delete this message?").append(new Html("div").classOn("fg-auto", "row").append(new Html("button").text("OK").classOn("fg-auto").on("click", () => {
        msg.cleanup();
        modal6.hide();
      })).append(new Html("button").text("Cancel").classOn("danger", "fg-auto").on("click", () => {
        modal6.hide();
      })));
      modal6 = new Modal(modalContainer);
      modal6.show();
    }));
  }
  msg.appendTo(store.get("messagesContainer"));
  window.mh = store.get("messageHistory");
  scrollDown();
  return msg;
}
function updateMessage(messageRef, data = null) {
  let x = messageRef.querySelector(".data");
  let y = messageRef.querySelector(".data .text");
  if (x !== null)
    x.classList.remove("muted", "dots-flow");
  if (data !== null) {
    if (data.startsWith('"'))
      data = data.slice(1);
    if (data.endsWith('"'))
      data = data.slice(0, -1);
    if (y !== null)
      y.innerHTML = purify_min2.default.sanitize(parseMarkdown(data));
  }
}
async function request(text, addUserMessage = true) {
  if (store.get("mpState") === true) {
    if (mpGetPromptsSelected().length === 0) {
      alert("You don't have any prompts in your multi-prompt.\nConfigure multi-prompt options in the Prompt Selection modal.");
      store.get("inputArea").elm.value = text;
      return;
    }
    const userIndex = store.get("messageHistory").push({
      role: "user",
      content: text,
      name: store.get("userSettings").username
    }) - 1;
    let human = new Html("div");
    if (addUserMessage === true) {
      human = makeMessage(0, purify_min2.default.sanitize(parseMarkdown(text)), userIndex);
    }
    let finalResponse = false;
    const personalities = await fetch("/api/getPersonality", {
      method: "post",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        prompt: text.substring(0, 1024),
        characters: mpGetPromptsSelected().map((p) => p.label),
        prevTalkingTo: store.get("select").elm.value
      })
    });
    let prevTalkingTo = null;
    finalResponse = await personalities.json();
    console.log("Personalities:", finalResponse);
    if (finalResponse === false) {
      return alert("Multi-prompt error: Couldn't detect a prompt to use.");
    }
    updateMessage(human.elm);
    for (let i = 0;i < finalResponse.length; i++) {
      const currentPrompt = finalResponse[i];
      const prompt = store.get("prompts").find((p) => p.label === currentPrompt);
      store.get("messageHistory").push({
        role: "user",
        name: store.get("userSettings").username,
        content: prevTalkingTo != null ? `You are now ${currentPrompt}. Respond as ${prompt?.displayName} after ${prevTalkingTo} last talked.` : `Respond as ${currentPrompt}.`
      }) - 1;
      if (prompt === undefined) {
        const assistants = loadAssistant();
        const customPromptId = await new Promise((resolve, reject) => {
          Object.keys(assistants).forEach((a) => {
            if (assistants[a].name === currentPrompt) {
              resolve(a);
            }
          });
        });
        setPrompt({ id: "custom", label: "Custom" }, false);
        store.set("loadedCustomPrompt", assistants[customPromptId]);
        store.get("loadedCustomPrompt").id = customPromptId;
        const z = JSON.stringify(store.get("loadedCustomPrompt"));
        importAndLoadPrompt(z, () => {
        });
      } else {
        setPrompt(prompt, false);
      }
      const aiIndex = store.get("messageHistory").push({
        role: "assistant",
        type: store.get("select").elm.value,
        content: "Thinking..."
      }) - 1;
      console.log("Selected prompt vs current prompt:", currentPrompt, prompt);
      let ai = makeMessage(1, "", aiIndex, prompt);
      isTyping = true;
      updateState();
      store.get("deleteConvoButton").elm.disabled = true;
      let result = await callAiMessage(ai.elm, text);
      store.get("messageHistory")[aiIndex].content = result;
      isTyping = false;
      updateState();
      store.get("deleteConvoButton").elm.disabled = false;
      prevTalkingTo = currentPrompt;
    }
  } else {
    const userIndex = store.get("messageHistory").push({
      role: "user",
      content: text,
      name: store.get("userSettings").username
    }) - 1;
    const aiIndex = store.get("messageHistory").push({
      role: "assistant",
      type: store.get("select").elm.value,
      content: "Thinking..."
    }) - 1;
    if (store.get("select").elm.value === "custom") {
      if (!store.get("loadedCustomPrompt").id) {
      } else
        store.get("messageHistory")[aiIndex].promptId = store.get("loadedCustomPrompt").id;
    }
    const prompt = store.get("prompts").find((p) => p.id === store.get("select").elm.value) || store.get("prompts")[0];
    let human = new Html("div");
    if (addUserMessage === true) {
      human = makeMessage(0, purify_min2.default.sanitize(parseMarkdown(text)), userIndex);
    }
    let ai = makeMessage(1, "", aiIndex, prompt);
    isTyping = true;
    updateState();
    store.get("deleteConvoButton").elm.disabled = true;
    let result = await callAiMessage(ai.elm, text);
    updateMessage(human.elm);
    store.get("messageHistory")[aiIndex].content = result;
    isTyping = false;
    updateState();
    store.get("deleteConvoButton").elm.disabled = false;
  }
  await checkRequests();
  updateRequestsMessage();
}
function startTextGeneration() {
  if (isTyping)
    return false;
  request(store.get("inputArea").elm.value);
  store.get("inputArea").elm.value = "";
  scrollDown();
  autoExpandTextArea();
  if (hasSetUp === false) {
    console.log("setting b4unload!");
    window.addEventListener("beforeunload", b4UnloadHandler, {
      capture: true
    });
    hasSetUp = true;
  }
}
function sendButton_StopGeneration() {
  try {
    if (store.get("currentSocket")?.cancel) {
      store.get("currentSocket").cancel("stop button").then(() => {
        window.dispatchEvent(new CustomEvent("chatify-premature-end", {
          detail: { data: "stop button", error: false }
        }));
      });
    }
  } catch (e) {
    console.log("failed to close");
  }
}
function sendButton_StartGeneration() {
  if (!isTyping) {
    startTextGeneration();
  }
}
function updateState() {
  switch (isTyping) {
    case true:
      store.get("inputArea").attr({ placeholder: "Thinking..." });
      store.get("sendButton").classOn("neutral").html(ICONS.stop).on("click", sendButton_StopGeneration).un("click", sendButton_StartGeneration);
      break;
    case false:
      store.get("inputArea").attr({ placeholder: "Message" });
      store.get("sendButton").classOff("neutral").html(ICONS.send).on("click", sendButton_StartGeneration).un("click", sendButton_StopGeneration);
      break;
  }
}
var isTyping = false;
var currentSocket = null;
var hasSetUp = false;
store.set("currentSocket", currentSocket);
var b4UnloadHandler = () => {
  return null;
};

// assets/lib/settingsListener.ts
function settingsListener() {
  window.addEventListener("storage", (e) => {
    loadUserSettings();
    window.dispatchEvent(new CustomEvent("chatify-settings-update", {
      detail: { data: e.newValue }
    }));
  });
  window.addEventListener("chatify-settings-update", function(e) {
    store.get("usernameInput").elm.value = store.get("userSettings").username;
    store.get("settings_enableUserName").elm.checked = store.get("userSettings").includeUsername;
    store.get("settings_rememberContextCheckbox").elm.checked = store.get("userSettings").rememberContext;
    store.get("themeSelect").elm.value = store.get("userSettings").theme;
    store.get("settings_showAvatarsCheckbox").elm.checked = store.get("userSettings").showAvatars;
    store.get("settings_showNamesCheckbox").elm.checked = store.get("userSettings").showNames;
    store.get("settings_showCopyBtnCheckbox").elm.checked = store.get("userSettings").showCopyButton;
    store.get("settings_showEditButtonCheckbox").elm.checked = store.get("userSettings").showEditButton;
    document.documentElement.dataset.showEditButton = store.get("userSettings").showEditButton;
    store.get("chatSelect").elm.value = store.get("userSettings").chatViewType;
    store.get("settings_togglePromptPrefixCheckbox").elm.checked = store.get("userSettings").promptPrefixEnabled;
    store.get("togglePpReadonly")();
    store.get("promptPrefixBox").elm.value = store.get("userSettings").promptPrefix;
    store.get("ctxLength").elm.value = store.get("userSettings").ctxLength;
    store.get("maxTokens").elm.value = store.get("userSettings").maxTokens;
    store.get("settings_testModeCheckbox").elm.checked = store.get("userSettings").testMode;
  });
  window.addEventListener("chatify-message-request", async (e) => {
    if (e.detail.history && e.detail.history === "remove") {
      store.set("messageHistory", []);
    }
    await request(e.detail.data, false);
  });
}

// assets/lib/ui/sidebar/conversation.ts
var purify_min3 = __toESM(require_purify_min(), 1);

// assets/lib/ui/separator.ts
function makeMsgSeparator(content = "The conversation resumes.") {
  new Html("div").append(new Html("span").classOn("text").text(content)).classOn("separator").appendTo(store.get("messagesContainer"));
  scrollDown();
}

// assets/lib/clearMessageHistory.ts
function actuallyClearMessageHistory() {
  store.set("messageHistory", []);
  store.get("messagesContainer").html("");
  makeMsgSeparator("Your conversation begins here.");
}
function clearMessageHistory() {
  if (confirm("Are you sure you want to clear your history?")) {
    try {
      sendButton_StopGeneration();
    } catch {
    }
    actuallyClearMessageHistory();
  }
}

// assets/lib/ui/sidebar/conversation.ts
function convoButton(container) {
  return new Html("button").text("Conversation...").class("fg").appendTo(container).on("click", () => {
    const modalContent = new Html("div").text("What do you want to do?").append(new Html("div").classOn("row").appendMany(new Html("button").text("Import").classOn("fg-auto").on("click", (e) => {
      const ta = new Html("textarea").attr({
        rows: "8",
        placeholder: '[ {"role": ..., "content": ...}, ... ]'
      });
      const modalContent2 = new Html("div").text("Import JSON data:").append(new Html("div").classOn("column").appendMany(ta, new Html("button").text("Attempt Import").classOn("fg-auto").on("click", () => {
        try {
          const convo = JSON.parse(ta.getValue());
          if (confirm("Are you sure you want to import?\nYou will lose your current conversation if it has not been saved.") === true) {
            md.hide();
            if (Array.isArray(convo)) {
              let items = convo.filter((m) => {
                if (m !== null && m.content && m.role) {
                  if (m.role === "assistant") {
                    if (m.type === "custom" || store.get("prompts").find((p) => p.id === m.type) !== undefined) {
                      return true;
                    }
                  } else if (m.role === "user") {
                    return true;
                  }
                  return false;
                }
              });
              actuallyClearMessageHistory();
              store.set("messageHistory", items);
              for (let i = 0;i < items.length; i++) {
                const item = items[i];
                setPrompt(store.get("prompts").find((p) => p.id === item.type) || store.get("prompts")[0], false);
                if (store.get("assistantObj") === null) {
                  store.set("assistantObj", loadAssistant());
                }
                let customPrompt = {
                  avatar: "",
                  name: "",
                  system: "",
                  temp: "0"
                };
                let isCustomPrompt = (item.promptId !== undefined && (item.promptId in store.get("assistantObj"))) === true;
                if (isCustomPrompt) {
                  customPrompt = store.get("assistantObj")[item.promptId];
                  const z = JSON.stringify(customPrompt);
                  setPrompt({
                    id: "custom",
                    label: "Custom"
                  });
                  importAndLoadPrompt(z, () => {
                  });
                }
                console.log(item);
                const pickedPrompt = item.role === "assistant" ? item.type === "custom" ? isCustomPrompt ? {
                  label: customPrompt.name,
                  id: "custom",
                  greeting: "Unset",
                  hint: "Unset",
                  type: "custom",
                  avatar: customPrompt.avatar,
                  displayName: customPrompt.name
                } : {
                  label: "Custom (unknown)",
                  id: "custom",
                  greeting: "Unset",
                  hint: "Unset",
                  type: "builtIn",
                  avatar: "./assets/avatars/builtin/custom.svg",
                  displayName: "Custom (unknown)"
                } : store.get("prompts").find((p) => p.id === item.type) : item.name ?? "User";
                let m = makeMessage(item.role === "user" ? 0 : 1, "Thinking...", i, pickedPrompt);
                if (item.role === "user") {
                  updateMessage(m.elm, item.content);
                } else {
                  m.qs(".data .text")?.html(purify_min3.default.sanitize(parseMarkdown(item.content)));
                }
              }
              makeMsgSeparator();
            }
          }
        } catch {
          md.hide();
        }
      })));
      modal7.hide();
      let md = new Modal(modalContent2);
      md.show();
    }), new Html("button").text("Export").classOn("fg-auto").on("click", () => {
      modal7.hide();
      const btn_modalContent = new Html("div").text("Here's your conversation:").append(new Html("textarea").attr({ rows: "8" }).html(JSON.stringify(store.get("messageHistory").filter((m) => m !== null))));
      const btn_modal = new Modal(btn_modalContent);
      btn_modal.show();
    })));
    const modal7 = new Modal(modalContent);
    modal7.show();
  });
}

// assets/lib/ui/sidebar/requestUi.ts
function requestUi(sideBar) {
  const requestUi_wrapper = new Html("div").classOn("column").appendTo(sideBar);
  const requestUi_text = new Html("span").text("Please wait..").appendTo(requestUi_wrapper);
  const requestUi_meter = new Html("div").classOn("meter").attr({ value: "0", max: "100" }).append(new Html("div").style({ width: "0%" })).appendTo(requestUi_wrapper);
  const requestUi_hint = new Html("span").classOn("small-text").text("..").appendTo(requestUi_wrapper);
  store.set("requestUi_wrapper", requestUi_wrapper);
  store.set("requestUi_text", requestUi_text);
  store.set("requestUi_meter", requestUi_meter);
  store.set("requestUi_hint", requestUi_hint);
}

// assets/lib/ui/sidebar/versionChecker.ts
async function versionCheck(container) {
  const versionData = await fetch("/api/version").then((j) => j.json());
  document.title = `Chatify ${versionData.version}`;
  const changelogLink = new Html("a").text(`See Changelogs`).on("click", () => {
    let mc = new Html("div").html(versionData.changelog);
    let m = new Modal(mc);
    m.show();
  });
  const debugVersionNumber = new Html("span").classOn("small-label").style({ "margin-top": "auto" }).html(versionData.footerNote).append(changelogLink).appendTo(container);
  store.set("debugVersionNumber", debugVersionNumber);
}

// assets/lib/ui/sidebar/toggleView.ts
function toggleButton(selectWrapper) {
  const toggleBtn = new Html("button").html(ICONS.chevron).class("fg-auto", "flip-off").appendTo(selectWrapper);
  toggleBtn.on("click", () => {
    if (store.get("menuState") === true) {
      store.set("menuState", false);
      toggleBtn.classOff("flip-off");
      toggleBtn.classOn("flip");
      store.get("multiRow").classOn("extra-hidden");
      store.get("customSettingsWrapper").classOn("extra-hidden");
      store.get("convoButton").classOn("extra-hidden");
      store.get("settingsBtn").classOn("extra-hidden");
      store.get("requestUi_wrapper").classOn("extra-hidden");
      store.get("heading").classOff("extra-hidden");
      store.get("deleteConvoButton").classOn("extra-hidden");
      toggleBtn.style({ "margin-left": "auto" });
      store.get("selectPromptBtn").classOn("extra-hidden");
      store.get("debugVersionNumber").classOn("extra-hidden");
      store.get("sideBar").classOn("mw-0");
    } else if (store.get("menuState") === false) {
      store.set("menuState", true);
      toggleBtn.classOff("flip");
      toggleBtn.classOn("flip-off");
      store.get("multiRow").classOff("extra-hidden");
      store.get("customSettingsWrapper").classOff("extra-hidden");
      store.get("convoButton").classOff("extra-hidden");
      store.get("settingsBtn").classOff("extra-hidden");
      store.get("requestUi_wrapper").classOff("extra-hidden");
      store.get("heading").classOn("extra-hidden");
      store.get("deleteConvoButton").classOff("extra-hidden");
      toggleBtn.style({ "margin-left": "unset" });
      store.get("selectPromptBtn").classOff("extra-hidden");
      store.get("debugVersionNumber").classOff("extra-hidden");
      store.get("sideBar").classOff("mw-0");
    }
  });
}

// assets/lib/ui/sidebar/customSettings.ts
function customSettings(sideBar) {
  store.set("aiNameOverride", false);
  store.set("aiAvatarOverride", false);
  const customSettingsWrapper = new Html("div").class("column", "bordered-box", "pt-0", "hidden").appendTo(sideBar);
  store.set("customSettingsWrapper", customSettingsWrapper);
  console.log(store.get("customSettingsWrapper"));
  const customSettings_systemPrompt = new Html("textarea").appendTo(customSettingsWrapper).attr({ type: "text", placeholder: "System prompt", rows: "4" });
  const customSettings_overrideName = new Html("input").appendTo(customSettingsWrapper).attr({ type: "text", placeholder: "Bot Name Override" }).on("input", (e) => {
    if (e.target != null) {
      store.set("aiNameOverride", e.target.value);
    }
    if (store.get("aiNameOverride") == "") {
      store.set("aiNameOverride", false);
    }
  });
  const customSettings_overrideAvatar = new Html("input").appendTo(customSettingsWrapper).attr({
    type: "text",
    placeholder: "Avatar Override, ex. https://...png"
  }).on("input", (e) => {
    if (e.target != null) {
      store.set("aiAvatarOverride", e.target.value);
    }
    if (store.get("aiAvatarOverride") == "") {
      store.set("aiAvatarOverride", false);
    }
  });
  store.set("customSettings_systemPrompt", customSettings_systemPrompt);
  store.set("customSettings_overrideName", customSettings_overrideName);
  store.set("customSettings_overrideAvatar", customSettings_overrideAvatar);
  const customSettings_tempWrapper = new Html("span").classOn("row", "py-0").appendTo(customSettingsWrapper);
  const customSettings_buttonsWrapper = new Html("span").classOn("row", "py-0").appendTo(customSettingsWrapper);
  new Html("button").text("Import").classOn("fg").appendTo(customSettings_buttonsWrapper).on("click", () => {
    const ta = new Html("textarea").attr({
      rows: "8",
      placeholder: "{ ... }"
    });
    const modalContent = new Html("div").text("Import JSON data:").append(new Html("div").classOn("column").appendMany(ta, new Html("button").text("Attempt Import").classOn("fg-auto").on("click", () => {
      importAndLoadPrompt(ta.getValue(), () => {
        modal9.hide();
      });
    })));
    const modal9 = new Modal(modalContent);
    modal9.show();
  });
  new Html("button").text("Export").class("fg").appendTo(customSettings_buttonsWrapper).on("click", () => {
    const modalContent = new Html("div").text("How do you want to export?").append(new Html("div").classOn("row").appendMany(new Html("button").text("JSON Export").classOn("fg-auto").on("click", () => {
      modal9.hide();
      const btn_modalContent = new Html("div").text("Here's your exported prompt:").append(new Html("textarea").attr({ rows: "8" }).html(JSON.stringify({
        system: customSettings_systemPrompt.getValue(),
        temp: customSettings_temp.getValue(),
        avatar: store.get("aiAvatarOverride"),
        name: store.get("aiNameOverride")
      })));
      const btn_modal = new Modal(btn_modalContent);
      btn_modal.show();
    }), new Html("button").text("Add to Saved").classOn("fg-auto").on("click", () => {
      modal9.hide();
      const assistants = loadAssistant();
      const x = store.get("aiNameOverride") || "prompt-" + Object.keys(assistants).length;
      const snakeCasedName = toSnakeCase(x);
      if (assistants[snakeCasedName]) {
        if (confirm(`Saving this prompt with the same name as "${snakeCasedName}" will forcefully overwrite it.\nAre you sure you want to do this?`) === true) {
          saveAssistant(snakeCasedName, {
            system: customSettings_systemPrompt.getValue(),
            temp: customSettings_temp.getValue(),
            avatar: store.get("aiAvatarOverride"),
            name: x
          });
        } else {
          return;
        }
      } else {
        saveAssistant(snakeCasedName, {
          system: customSettings_systemPrompt.getValue(),
          temp: customSettings_temp.getValue(),
          avatar: store.get("aiAvatarOverride"),
          name: store.get("aiNameOverride")
        });
      }
      let m = new Html("span").text("Saved! Open the prompt picker and go to Saved to see your creation.");
      let md = new Modal(m);
      md.show();
    })));
    const modal9 = new Modal(modalContent);
    modal9.show();
  });
  new Html("label").attr({ for: "temp" }).text("Temperature").appendTo(customSettings_tempWrapper);
  const customSettings_temp = new Html("input").attr({ id: "temp", type: "range", min: "0", max: "1", step: "0.01" }).appendTo(customSettings_tempWrapper);
  store.set("customSettings_temp", customSettings_temp);
}

// assets/lib/ui/sidebar.ts
async function setupSidebar() {
  const sideBar = new Html("div").class("config").appendTo("body");
  store.set("sideBar", sideBar);
  const selectWrapper = new Html("div").class("row").appendTo(sideBar);
  const heading = new Html("span").text("Chatify").classOn("extra-hidden", "label").appendTo(selectWrapper);
  store.set("heading", heading);
  const deleteConvoButton = new Html("button").html(ICONS.trashCan).classOn("center", "danger", "fg-auto").appendTo(selectWrapper).on("click", () => clearMessageHistory());
  store.set("deleteConvoButton", deleteConvoButton);
  const select = new Html("select").class("fg", "extra-hidden").appendTo(selectWrapper);
  store.set("select", select);
  const prompts = await getPrompts();
  prompts.forEach((e) => {
    select.elm.appendChild(new Option(e.label, e.id));
  });
  select.elm.append(new Option("Custom", "custom"));
  const selectWrapperMiddle = new Html("div").class("fg").appendTo(selectWrapper);
  toggleButton(selectWrapper);
  customSettings(sideBar);
  const selectPromptBtn = new Html("button").text("Select prompt..").classOn("transparent", "fg", "w-100").appendTo(selectWrapperMiddle).on("click", async () => {
    await promptPick();
  });
  store.set("selectPromptBtn", selectPromptBtn);
  let userName = localStorage.getItem("remembered-name") ?? "User";
  store.set("userName", userName);
  const multiRow = new Html("div").classOn("row").appendTo(sideBar);
  store.set("multiRow", multiRow);
  store.set("convoButton", convoButton(multiRow));
  store.set("settingsBtn", settingsBtn(multiRow));
  requestUi(sideBar);
  await versionCheck(sideBar);
  await checkRequests();
  updateRequestsMessage();
}

// assets/lib/base.ts
settingsListener();
store.set("assistantObj", null);
store.set("loadedCustomPrompt", {});
store.set("lastScrollTop", -1);
store.set("lastScrollHeight", -1);
store.set("OPENAI_URL_WS", `${location.protocol.replace("http", "ws")}//${location.host}/stream`);
await setupSidebar();
setupMessages();
store.set("messageHistory", []);
store.set("menuState", true);
makeMsgSeparator("Your conversation begins here.");
updateState();
